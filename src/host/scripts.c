/* Premake's Lua scripts, as static data buffers for release mode builds */
/* To regenerate this file, run: premake4 embed */ 

const char* builtin_scripts[] = {
	"--\n\n\n\nfunction os.findlib(libname)\nlocal path, formats\n\n-- assemble a search path, depending on the platform\nif os.is(\"windows\") then\nformats = { \"%s.dll\", \"%s\" }\npath = os.getenv(\"PATH\")\nelse\nif os.is(\"macosx\") then\nformats = { \"lib%s.dylib\", \"%s.dylib\" }\npath = os.getenv(\"DYLD_LIBRARY_PATH\")\nelse\nformats = { \"lib%s.so\", \"%s.so\" }\npath = os.getenv(\"LD_LIBRARY_PATH\") or \"\"\n\nlocal f = io.open(\"/etc/ld.so.conf\", \"r\")\nif f then\nfor line in f:lines() do\npath = path .. \":\" .. line\nend\nf:close()\nend\nend\n\ntable.insert(formats, \"%s\")\npath = (path or \"\") .. \":/lib:/usr/lib:/usr/local/lib\"\nend\n\nfor _, fmt in ipairs(formats) do\nlocal name = string.format(fmt, libname)\nlocal result = os.pathsearch(name, path)\nif result then return result end\nend\nend\n\n\n\n\nfunction os.get()\nreturn _OPTIONS.os or _OS\nend\n\n\n\n\nfunction os.is(id)\nreturn (os.get():lower() == id:lower())\nend\n\n\n\n\nlocal function domatch(result, mask, wantfiles)\nlocal basedir = path.getdirectory(mask)\nif (basedir == \".\") then basedir = \"\" end\n\nlocal m = os.matchstart(mask)\nwhile (os.matchnext(m)) do\nlocal fname = os.matchname(m)\nlocal isfile = os.matchisfile(m)\nif ((wantfiles and isfile) or (not wantfiles and not isfile)) then\ntable.insert(result, path.join(basedir, fname))\nend\nend\nos.matchdone(m)\n\n-- if the mask uses \"**\", recurse subdirectories\nif (mask:find(\"**\", nil, true)) then\nmask = path.getname(mask)\nm = os.matchstart(path.join(basedir, \"*\"))\nwhile (os.matchnext(m)) do\nlocal dirname = os.matchname(m)\nlocal submask = path.join(path.join(basedir, dirname), mask)\ndomatch(result, submask, wantfiles)\nend\nos.matchdone(m)\nend\nend\n\nfunction os.matchdirs(...)\nlocal result = { }\nfor _, mask in ipairs(arg) do\ndomatch(result, mask, false)\nend\nreturn result\nend\n\nfunction os.matchfiles(...)\nlocal result = { }\nfor _, mask in ipairs(arg) do\ndomatch(result, mask, true)\nend\nreturn result\nend\n\n\n\n\nlocal builtin_mkdir = os.mkdir\nfunction os.mkdir(p)\nlocal dir = iif(p:startswith(\"/\"), \"/\", \"\")\nfor part in p:gmatch(\"[^/]+\") do\ndir = dir .. part\n\nif (part ~= \"\" and not path.isabsolute(part) and not os.isdir(dir)) then\nlocal ok, err = builtin_mkdir(dir)\nif (not ok) then\nreturn nil, err\nend\nend\n\ndir = dir .. \"/\"\nend\n\nreturn true\nend\n\n\n\nlocal builtin_rmdir = os.rmdir\nfunction os.rmdir(p)\n-- recursively remove subdirectories\nlocal dirs = os.matchdirs(p .. \"/*\")\nfor _, dname in ipairs(dirs) do\nos.rmdir(dname)\nend\n\n-- remove any files\nlocal files = os.matchfiles(p .. \"/*\")\nfor _, fname in ipairs(files) do\nos.remove(fname)\nend\n\n-- remove this directory\nbuiltin_rmdir(p)\nend\n\n",
	"--\n\n\npath = { }\n\n\n\nfunction path.getabsolute(p)\n-- normalize the target path\np = path.translate(p, \"/\")\nif (p == \"\") then p = \".\" end\n\n-- if the directory is already absolute I don't need to do anything\nlocal result = iif (path.isabsolute(p), nil, os.getcwd())\n\n-- split up the supplied relative path and tackle it bit by bit\nfor _,part in ipairs(p:explode(\"/\", true)) do\nif (part == \"\") then\nresult = \"/\"\nelseif (part == \"..\") then\nresult = path.getdirectory(result)\nelseif (part ~= \".\") then\nresult = path.join(result, part)\nend\nend\n\nreturn result\nend\n\n\n\nfunction path.getbasename(p)\nlocal name = path.getname(p)\nlocal i = name:findlast(\".\", true)\nif (i) then\nreturn name:sub(1, i - 1)\nelse\nreturn name\nend\nend\n\n\n\nfunction path.getdirectory(p)\nlocal i = p:findlast(\"/\", true)\nif (i) then\nif i > 1 then i = i - 1 end\nreturn p:sub(1, i)\nelse\nreturn \".\"\nend\nend\n\n\n\nfunction path.getdrive(p)\nlocal ch1 = p:sub(1,1)\nlocal ch2 = p:sub(2,2)\nif ch2 == \":\" then\nreturn ch1\nend\nend\n\n\n\n\nfunction path.getextension(p)\nlocal i = p:findlast(\".\", true)\nif (i) then\nreturn p:sub(i)\nelse\nreturn \"\"\nend\nend\n\n\n\n\nfunction path.getname(p)\nlocal i = p:findlast(\"[/\\\\]\")\nif (i) then\nreturn p:sub(i + 1)\nelse\nreturn p\nend\nend\n\n\n\nfunction path.getrelative(src, dst)\n-- normalize the two paths\nsrc = path.getabsolute(src)\ndst = path.getabsolute(dst)\n\n-- same directory?\nif (src == dst) then\nreturn \".\"\nend\n\n-- different drives? Must use absolute path\nif path.getdrive(src) ~= path.getdrive(dst) then\nreturn dst\nend\n\nsrc = src .. \"/\"\ndst = dst .. \"/\"\n\n-- trim off the common directories from the front \nlocal i = src:find(\"/\")\nwhile (i) do\nif (src:sub(1,i) == dst:sub(1,i)) then\nsrc = src:sub(i + 1)\ndst = dst:sub(i + 1)\nelse\nbreak\nend\ni = src:find(\"/\")\nend\n\n-- back up from dst to get to this common parent\nlocal result = \"\"\ni = src:find(\"/\")\nwhile (i) do\nresult = result .. \"../\"\ni = src:find(\"/\", i + 1)\nend\n\n-- tack on the path down to the dst from here\nresult = result .. dst\n\n-- remove the trailing slash\nreturn result:sub(1, -2)\nend\n\n\n\nfunction path.isabsolute(p)\nlocal ch1 = p:sub(1,1)\nlocal ch2 = p:sub(2,2)\nreturn (ch1 == \"/\" or ch1 == \"\\\\\" or ch2 == \":\")\nend\n\n\n\nfunction path.iscfile(fname)\nlocal extensions = { \".c\", \".s\" }\nlocal ext = path.getextension(fname):lower()\nreturn table.contains(extensions, ext)\nend\n\nfunction path.iscppfile(fname)\nlocal extensions = { \".cc\", \".cpp\", \".cxx\", \".c\", \".s\" }\nlocal ext = path.getextension(fname):lower()\nreturn table.contains(extensions, ext)\nend\n\n\n\nfunction path.isresourcefile(fname)\nlocal extensions = { \".rc\" }\nlocal ext = path.getextension(fname):lower()\nreturn table.contains(extensions, ext)\nend\n\n\n\n\nfunction path.join(leading, trailing)\nif (not leading) then \nleading = \"\" \nend\n\nif (not trailing) then\nreturn leading\nend\n\nif (path.isabsolute(trailing)) then\nreturn trailing\nend\n\nif (leading == \".\") then\nleading = \"\"\nend\n\nif (leading:len() > 0 and not leading:endswith(\"/\")) then\nleading = leading .. \"/\"\nend\n\nreturn leading .. trailing\nend\n\n\n\nfunction path.rebase(p, oldbase, newbase)\np = path.getabsolute(path.join(oldbase, p))\np = path.getrelative(newbase, p)\nreturn p\nend\n\n\n\nfunction path.translate(p, sep)\nif (type(p) == \"table\") then\nlocal result = { }\nfor _, value in ipairs(p) do\ntable.insert(result, path.translate(value))\nend\nreturn result\nelse\nif (not sep) then\nif (os.is(\"windows\")) then\nsep = \"\\\\\"\nelse\nsep = \"/\"\nend\nend\nlocal result = p:gsub(\"[/\\\\]\", sep)\nreturn result\nend\nend\n",
	"--\n\n\n\nfunction string.endswith(haystack, needle)\nif (haystack and needle) then\nlocal hlen = haystack:len()\nlocal nlen = needle:len()\nif (hlen >= nlen) then\nreturn (haystack:sub(-nlen) == needle)\nend\nend\n\nreturn false\nend\n\n\n\nfunction string.explode(s, pattern, plain)\nif (pattern == '') then return false end\nlocal pos = 0\nlocal arr = { }\nfor st,sp in function() return s:find(pattern, pos, plain) end do\ntable.insert(arr, s:sub(pos, st-1))\npos = sp + 1\nend\ntable.insert(arr, s:sub(pos))\nreturn arr\nend\n\n\n\n\nfunction string.findlast(s, pattern, plain)\nlocal curr = 0\nrepeat\nlocal next = s:find(pattern, curr + 1, plain)\nif (next) then curr = next end\nuntil (not next)\nif (curr > 0) then\nreturn curr\nend\nend\n\n\n\n\nfunction string.startswith(haystack, needle)\nreturn (haystack:find(needle, 1, true) == 1)\nend",
	"--\n\n\n\nfunction table.contains(t, value)\nfor _,v in pairs(t) do\nif (v == value) then\nreturn true\nend\nend\nreturn false\nend\n\n\n\nfunction table.extract(arr, fname)\nlocal result = { }\nfor _,v in ipairs(arr) do\ntable.insert(result, v[fname])\nend\nreturn result\nend\n\n\n\n\nfunction table.implode(arr, before, after, between)\nlocal result = \"\"\nfor _,v in ipairs(arr) do\nif (result ~= \"\" and between) then\nresult = result .. between\nend\nresult = result .. before .. v .. after\nend\nreturn result\nend\n\n\n\nfunction table.join(...)\nlocal result = { }\nfor _,t in ipairs(arg) do\nif type(t) == \"table\" then\nfor _,v in ipairs(t) do\ntable.insert(result, v)\nend\nelse\ntable.insert(result, t)\nend\nend\nreturn result\nend\n\n\n\nfunction table.translate(arr, translation)\nlocal result = { }\nfor _, value in ipairs(arr) do\nlocal tvalue\nif type(translation) == \"function\" then\ntvalue = translation(value)\nelse\ntvalue = translation[value]\nend\nif (tvalue) then\ntable.insert(result, tvalue)\nend\nend\nreturn result\nend\n\n",
	"--\n\n\n\nfunction io.capture()\nio.captured = ''\nend\n\n\n\n\nfunction io.endcapture()\nlocal captured = io.captured\nio.captured = nil\nreturn captured\nend\n\n\n\nlocal builtin_open = io.open\nfunction io.open(fname, mode)\nif (mode) then\nif (mode:find(\"w\")) then\nlocal dir = path.getdirectory(fname)\nok, err = os.mkdir(dir)\nif (not ok) then\nerror(err, 0)\nend\nend\nend\nreturn builtin_open(fname, mode)\nend\n\n\n\n\nfunction io.printf(msg, ...)\nif (not io.eol) then\nio.eol = \"\\n\"\nend\n\nlocal s = string.format(msg, unpack(arg))\nif io.captured then\nio.captured = io.captured .. s .. io.eol\nelse\nio.write(s)\nio.write(io.eol)\nend\nend\n\n\n\n_p = io.printf\n",
	"--\n\n\n\n_SOLUTIONS = { }\n\n\n\n_TEMPLATES = { }\n\n\n\npremake = { }\n\n\n\npremake.actions = { }\npremake.options = { }\n\n\n\n\nlocal builtin_dofile = dofile\nfunction dofile(fname)\n-- remember the current working directory; I'll restore it shortly\nlocal oldcwd = os.getcwd()\n\n-- if the file doesn't exist, check the search path\nif (not os.isfile(fname)) then\nlocal path = os.pathsearch(fname, _OPTIONS[\"scripts\"], os.getenv(\"PREMAKE_PATH\"))\nif (path) then\nfname = path..\"/\"..fname\nend\nend\n\n-- use the absolute path to the script file, to avoid any file name\n-- ambiguity if an error should arise\nfname = path.getabsolute(fname)\n\n-- switch the working directory to the new script location\nlocal newcwd = path.getdirectory(fname)\nos.chdir(newcwd)\n\n-- run the chunk. How can I catch variable return values?\nlocal a, b, c, d, e, f = builtin_dofile(fname)\n\n-- restore the previous working directory when done\nos.chdir(oldcwd)\nreturn a, b, c, d, e, f\nend\n\n\n\n\nfunction iif(expr, trueval, falseval)\nif (expr) then\nreturn trueval\nelse\nreturn falseval\nend\nend\n\n\n\n\nfunction include(fname)\nreturn dofile(fname .. \"/premake4.lua\")\nend\n\n\n\n\nfunction printf(msg, ...)\nprint(string.format(msg, unpack(arg)))\nend\n\n\n\n\nlocal builtin_type = type\nfunction type(t)\nlocal mt = getmetatable(t)\nif (mt) then\nif (mt.__type) then\nreturn mt.__type\nend\nend\nreturn builtin_type(t)\nend\n",
	"--\n\n\n\nlocal function literal(str)\nlocal code = \"\"\n\nfor line in str:gmatch(\"[^\\n]*\") do\nif (line:len() > 0) then\ncode = code .. \"io.write[=[\" .. line .. \"]=]\"\nelse\ncode = code .. \"io.write(eol)\\n\"\nend\nend\n\nreturn code:sub(1, -15)\nend\n\n\n\n\nfunction premake.encodetemplate(tmpl)\ncode = \"\"\n\n-- normalize line endings\ntmpl = tmpl:gsub(\"\\r\\n\", \"\\n\")\n\nwhile (true) do\n-- find an escaped block\nstart, finish = tmpl:find(\"<%%.-%%>\")\nif (not start) then break end\n\nlocal before = tmpl:sub(1, start - 1)\nlocal after  = tmpl:sub(finish + 1)\n\n-- get the block type and contents\nlocal block\nlocal isexpr = (tmpl:sub(start + 2, start + 2) == \"=\")\nif (isexpr) then\nblock = tmpl:sub(start + 3, finish - 2)\nelse\nblock = tmpl:sub(start + 2, finish - 2)\nend\n\n-- if a statement block, strip out everything else on that line\nif (not isexpr) then\nfinish = before:findlast(\"\\n\", true)\nif (finish) then \nbefore = before:sub(1, finish)\nelse\nbefore = nil\nend\n\nstart = after:find(\"\\n\", 1, true)\nif (start) then \nafter = after:sub(start + 1) \nend\nend\n\n-- output everything before the block\nif (before) then\ncode = code .. literal(before)\nend\n\n-- output the block itself\nif (isexpr) then\ncode = code .. \"io.write(\" .. block .. \")\"\nelse\ncode = code .. block .. \"\\n\"\nend\n\n-- do it again, with everything after the block\ntmpl = after\nend\n\n-- tack on everything after the last block\ncode = code .. literal(tmpl)\nreturn code\nend\n\n\n\n\nfunction premake.loadtemplatestring(name, str)\nlocal code = premake.encodetemplate(str)\nlocal fn, msg = loadstring(\"return function (this) eol='\\\\n';\" .. code .. \" end\", name)\nif (not fn) then\nerror(msg, 0)\nend\nreturn fn()\nend\n\n\n\n\nfunction premake.getoutputname(this, namespec)\nlocal fname\nif (type(namespec) == \"function\") then\nfname = namespec(this)\nelse\nfname = this.name .. namespec\nend\nreturn path.join(this.location, fname)\nend\n\n\n\n\nfunction premake.loadtemplatefile(fname)\nlocal f = io.open(fname, \"rb\")\nlocal tmpl = f:read(\"*a\")\nf:close()\nreturn premake.loadtemplatestring(path.getname(fname), tmpl)\nend\n\n",
	"--\n\n\n\nfunction premake.eachconfig(prj, platform)\n-- I probably have the project root config, rather than the actual project\nif prj.project then prj = prj.project end\n\nlocal cfgs = prj.solution.configurations\nlocal i = 0\n\nreturn function ()\ni = i + 1\nif i <= #cfgs then\nreturn premake.getconfig(prj, cfgs[i], platform)\nend\nend\nend\n\n\n\n\nfunction premake.eachfile(prj)\n-- project root config contains the file config list\nif not prj.project then prj = premake.getconfig(prj) end\nlocal i = 0\nlocal t = prj.files\nreturn function ()\ni = i + 1\nif (i <= #t) then\nreturn prj.__fileconfigs[t[i]]\nend\nend\nend\n\n\n\n\nfunction premake.eachproject(sln)\nlocal i = 0\nreturn function ()\ni = i + 1\nif (i <= #sln.projects) then\nlocal prj = sln.projects[i]\nlocal cfg = premake.getconfig(prj)\ncfg.name  = prj.name\ncfg.blocks = prj.blocks\nreturn cfg\nend\nend\nend\n\n\n\n\nfunction premake.esc(value)\nif (type(value) == \"table\") then\nlocal result = { }\nfor _,v in ipairs(value) do\ntable.insert(result, premake.esc(v))\nend\nreturn result\nelse\nvalue = value:gsub('&',  \"&amp;\")\nvalue = value:gsub('\"',  \"&quot;\")\nvalue = value:gsub(\"'\",  \"&apos;\")\nvalue = value:gsub('<',  \"&lt;\")\nvalue = value:gsub('>',  \"&gt;\")\nvalue = value:gsub('\\r', \"&#x0D;\")\nvalue = value:gsub('\\n', \"&#x0A;\")\nreturn value\nend\nend\n\n\n\n\nfunction premake.filterplatforms(sln, map, default)\nlocal result = { }\nlocal keys = { }\nif sln.platforms then\nfor _, p in ipairs(sln.platforms) do\nif map[p] and not table.contains(keys, map[p]) then\ntable.insert(result, p)\ntable.insert(keys, map[p])\nend\nend\nend\n\nif #result == 0 and default then\ntable.insert(result, default)\nend\n\nreturn result\nend\n\n\n\n\nfunction premake.findproject(name)\nname = name:lower()\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nif (prj.name:lower() == name) then\nreturn prj\nend\nend\nend\nend\n\n\n\n\nfunction premake.findfile(prj, extension)\nfor _, fname in ipairs(prj.files) do\nif fname:endswith(extension) then return fname end\nend\nend\n\n\n\n\nfunction premake.getconfig(prj, cfgname, pltname)\n-- might have the root configuration, rather than the actual project\nif prj.project then prj = prj.project end\n\n-- if platform is not included in the solution, use general settings instead\nif pltname == \"Native\" or not table.contains(prj.solution.platforms or {}, pltname) then\npltname = nil\nend\n\nlocal key = (cfgname or \"\")\nif pltname then key = key .. \":\" .. pltname end\nreturn prj.__configs[key]\nend\n\n\n\n\nfunction premake.getdependencies(cfg)\nlocal results = { }\nfor _, link in ipairs(cfg.links) do\nlocal prj = premake.findproject(link)\nif (prj) then\ntable.insert(results, prj)\nend\nend\nreturn results\nend\n\n\n\n\nfunction premake.getlinks(cfg, kind, part)\n-- if I'm building a list of link directories, include libdirs\nlocal result = iif (part == \"directory\" and kind == \"all\", cfg.libdirs, {})\n\n-- am I getting links for a configuration or a project?\nlocal cfgname = iif(cfg.name == cfg.project.name, \"\", cfg.name)\n\nlocal function canlink(source, target)\nif (target.kind ~= \"SharedLib\" and target.kind ~= \"StaticLib\") then return false end\nif (source.language == \"C\" or source.language == \"C++\") then\nif (target.language ~= \"C\" and target.language ~= \"C++\") then return false end\nreturn true\nelseif (source.language == \"C#\") then\nif (target.language ~= \"C#\") then return false end\nreturn true\nend\nend\n\nfor _, link in ipairs(cfg.links) do\nlocal item\n\n-- is this a sibling project?\nlocal prj = premake.findproject(link)\nif prj and kind ~= \"system\" then\n\nlocal prjcfg = premake.getconfig(prj, cfgname)\nif kind == \"dependencies\" or canlink(cfg, prjcfg) then\nif (part == \"directory\") then\nitem = path.rebase(prjcfg.linktarget.directory, prjcfg.location, cfg.location)\nelseif (part == \"basename\") then\nitem = prjcfg.linktarget.basename\nelseif (part == \"fullpath\") then\nitem = path.rebase(prjcfg.linktarget.fullpath, prjcfg.location, cfg.location)\nelseif (part == \"object\") then\nitem = prjcfg\nend\nend\n\nelseif not prj and (kind == \"system\" or kind == \"all\") then\n\nif (part == \"directory\") then\nlocal dir = path.getdirectory(link)\nif (dir ~= \".\") then\nitem = dir\nend\nelseif (part == \"fullpath\") then\nitem = link\nif premake.actions[_ACTION].targetstyle == \"windows\" then\nitem = item .. iif(cfg.language == \"C\" or cfg.language == \"C++\", \".lib\", \".dll\")\nend\nif item:find(\"/\", nil, true) then\nitem = path.getrelative(cfg.basedir, item)\nend\nelse\nitem = link\nend\n\nend\n\nif item then\nif premake.actions[_ACTION].targetstyle == \"windows\" and part ~= \"object\" then\nitem = path.translate(item, \"\\\\\")\nend\nif not table.contains(result, item) then\ntable.insert(result, item)\nend\nend\nend\n\nreturn result\nend\n\n\n\n\nfunction premake.gettarget(cfg, direction, style, os)\n-- normalize the arguments\nif not os then os = _G[\"os\"].get() end\nif (os == \"bsd\") then os = \"linux\" end\n\nlocal kind = cfg.kind\nif (cfg.language == \"C\" or cfg.language == \"C++\") then\n-- On Windows, shared libraries link against a static import library\nif (style == \"windows\" or os == \"windows\") and kind == \"SharedLib\" and direction == \"link\" then\nkind = \"StaticLib\"\nend\n\n-- Linux name conventions only apply to static libs on windows (by user request)\nif (style == \"linux\" and os == \"windows\" and kind ~= \"StaticLib\") then\nstyle = \"windows\"\nend\nelseif (cfg.language == \"C#\") then\n-- .NET always uses Windows naming conventions\nstyle = \"windows\"\nend\n\n-- Initialize the target components\nlocal field   = iif(direction == \"build\", \"target\", \"implib\")\nlocal name    = cfg[field..\"name\"] or cfg.targetname or cfg.project.name\nlocal dir     = cfg[field..\"dir\"] or cfg.targetdir or path.getrelative(cfg.location, cfg.basedir)\nlocal prefix  = \"\"\nlocal suffix  = \"\"\n\n-- If using an import library and \"NoImportLib\" flag is set, library will be in objdir\nif cfg.kind == \"SharedLib\" and kind == \"StaticLib\" and cfg.flags.NoImportLib then\ndir = cfg.objectsdir\nend\n\nif style == \"windows\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\nsuffix = \".exe\"\nelseif kind == \"SharedLib\" then\nsuffix = \".dll\"\nelseif kind == \"StaticLib\" then\nsuffix = \".lib\"\nend\nelseif style == \"linux\" then\nif (kind == \"WindowedApp\" and os == \"macosx\") then\ndir = path.join(dir, name .. \".app/Contents/MacOS\")\nelseif kind == \"SharedLib\" then\nprefix = \"lib\"\nsuffix = \".so\"\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\nsuffix = \".a\"\nend\nend\n\nprefix = cfg[field..\"prefix\"] or cfg.targetprefix or prefix\nsuffix = cfg[field..\"extension\"] or cfg.targetextension or suffix\n\nlocal result = { }\nresult.basename  = name\nresult.name      = prefix .. name .. suffix\nresult.directory = dir\nresult.fullpath  = path.join(result.directory, result.name)\nreturn result\nend\n\n\n\n\nfunction premake.hascppproject(sln)\nfor prj in premake.eachproject(sln) do\nif premake.iscppproject(prj) then\nreturn true\nend\nend\nend\n\n\n\n\nfunction premake.hasdotnetproject(sln)\nfor prj in premake.eachproject(sln) do\nif premake.isdotnetproject(prj) then\nreturn true\nend\nend\nend\n\n\n\n\nfunction premake.iscppproject(prj)\nreturn (prj.language == \"C\" or prj.language == \"C++\")\nend\n\n\n\n\nfunction premake.isdotnetproject(prj)\nreturn (prj.language == \"C#\")\nend\n\n\n\n\nlocal function walksources(prj, files, fn, group, nestlevel, finished)\nlocal grouplen = group:len()\nlocal gname = iif(group:endswith(\"/\"), group:sub(1, -2), group)\n\n-- open this new group\nif (nestlevel >= 0) then\nfn(prj, gname, \"GroupStart\", nestlevel)\nend\n\n-- scan the list of files for items which belong in this group\nfor _,fname in ipairs(files) do\nif (fname:startswith(group)) then\n\n-- is there a subgroup within this item?\nlocal _,split = fname:find(\"[^\\.]/\", grouplen + 1)\nif (split) then\nlocal subgroup = fname:sub(1, split)\nif (not finished[subgroup]) then\nfinished[subgroup] = true\nwalksources(prj, files, fn, subgroup, nestlevel + 1, finished)\nend\nend\n\nend\nend\n\n-- process all files that belong in this group\nfor _,fname in ipairs(files) do\nif (fname:startswith(group) and not fname:find(\"[^\\.]/\", grouplen + 1)) then\nfn(prj, fname, \"GroupItem\", nestlevel + 1)\nend\nend\n\n-- close the group\nif (nestlevel >= 0) then\nfn(prj, gname, \"GroupEnd\", nestlevel)\nend\nend\n\n\nfunction premake.walksources(prj, files, fn)\nwalksources(prj, files, fn, \"\", -1, {})\nend\n",
	"--\n\n\n-- do not copy these fields into the configurations\nlocal nocopy = \n{\nblocks   = true,\nkeywords = true,\nprojects = true,\n}\n\n-- leave these paths as absolute, rather than converting to project relative\nlocal nofixup =\n{\nbasedir  = true,\nlocation = true,\n}\n\n\n\n\nfunction premake.getactiveterms()\nlocal terms = { _ACTION:lower(), os.get() }\n\n-- add option keys or values\nfor key, value in pairs(_OPTIONS) do\nif value ~= \"\" then\ntable.insert(terms, value:lower())\nelse\ntable.insert(terms, key:lower())\nend\nend\n\nreturn terms\nend\n\n\n\n\nfunction premake.escapekeyword(keyword)\nkeyword = keyword:gsub(\"([%.%-%^%$%(%)%%])\", \"%%%1\")\nif keyword:find(\"**\", nil, true) then\nkeyword = keyword:gsub(\"%*%*\", \".*\")\nelse\nkeyword = keyword:gsub(\"%*\", \"[^/]*\")\nend\nreturn keyword:lower()\nend\n\n\n\n\nfunction premake.iskeywordmatch(keyword, terms)\n-- is it negated?\nif keyword:startswith(\"not \") then\nreturn not premake.iskeywordmatch(keyword:sub(5), terms)\nend\n\nfor _, word in ipairs(keyword:explode(\" or \")) do\nlocal pattern = \"^\" .. word .. \"$\"\nfor termkey, term in pairs(terms) do\nif term:match(pattern) then\nreturn termkey\nend\nend\nend\nend\n\n\n\n\nfunction premake.iskeywordsmatch(keywords, terms)\nlocal hasrequired = false\nfor _, keyword in ipairs(keywords) do\nlocal matched = premake.iskeywordmatch(keyword, terms)\nif not matched then\nreturn false\nend\nif matched == \"required\" then\nhasrequired = true\nend\nend\n\nif terms.required and not hasrequired then\nreturn false\nelse\nreturn true\nend\nend\n\n\n\n\nlocal function copyfields(cfg, this)\nfor field,value in pairs(this) do\nif (not nocopy[field]) then\nif (type(value) == \"table\") then\nif (not cfg[field]) then cfg[field] = { } end\ncfg[field] = table.join(cfg[field], value) \nelse\ncfg[field] = value\nend\nend\nend\nend\n\n\n\n\nlocal function buildconfig(prj, terms)\n-- fields are copied first from the solution, then the solution's configs,\n-- then from the project, then the project's configs. Each can overwrite\n-- or add to the values set previously. The objdir field gets special\n-- treatment, in order to provide a project-level default and still enable\n-- solution-level overrides\n\nlocal cfg = { }\n\ncopyfields(cfg, prj.solution)\nfor _,blk in ipairs(prj.solution.blocks) do\nif (premake.iskeywordsmatch(blk.keywords, terms)) then\ncopyfields(cfg, blk)\nend\nend\n\ncopyfields(cfg, prj)\nfor _,blk in ipairs(prj.blocks) do\nif (premake.iskeywordsmatch(blk.keywords, terms)) then\ncopyfields(cfg, blk)\nend\nend\n\nreturn cfg\nend\n\n\n\n\nlocal function buildprojectconfig(prj, cfgname, pltname)\npltname = pltname or \"Native\"\n\n-- create the base configuration, flattening the list of objects and\n-- filtering out settings which do not match the current environment\nlocal terms = premake.getactiveterms()\nterms.platform = pltname:lower()\nterms.config   = (cfgname or \"\"):lower()\n\nlocal cfg    = buildconfig(prj, terms)\ncfg.name     = cfgname\ncfg.platform = pltname\ncfg.project  = prj\n\n-- set the project location, if not already set\ncfg.location = cfg.location or cfg.basedir\n\n-- remove excluded files from the file list\nlocal files = { }\nfor _, fname in ipairs(cfg.files) do\nlocal excluded = false\nfor _, exclude in ipairs(cfg.excludes) do\nexcluded = (fname == exclude)\nif (excluded) then break end\nend\n\nif (not excluded) then\ntable.insert(files, fname)\nend\nend\ncfg.files = files\n\n-- fixup the data\nfor name, field in pairs(premake.fields) do\n-- convert absolute paths to project relative\nif (field.kind == \"path\" or field.kind == \"dirlist\" or field.kind == \"filelist\") and (not nofixup[name]) then\nif type(cfg[name]) == \"table\" then\nfor i,p in ipairs(cfg[name]) do cfg[name][i] = path.getrelative(prj.location, p) end\nelse\nif cfg[name] then cfg[name] = path.getrelative(prj.location, cfg[name]) end\nend\nend\n\n-- re-key flag fields for faster lookups\nif field.isflags then\nlocal values = cfg[name]\nfor _, flag in ipairs(values) do values[flag] = true end\nend\nend\n\n-- build configuration objects for all files\ncfg.__fileconfigs = { }\nfor _, fname in ipairs(cfg.files) do\nterms.required = fname:lower()\nlocal fcfg = buildconfig(prj, terms)\nfcfg.name = fname\n-- add indexed by name and integer\ncfg.__fileconfigs[fname] = fcfg\ntable.insert(cfg.__fileconfigs, fcfg)\nend\n\nreturn cfg\nend\n\n\n\n\nlocal function buildtargets(cfg)\n\n-- deduce and store the applicable tool for this configuration\nif cfg.language == \"C\" or cfg.language == \"C++\" then\nif _OPTIONS.cc then cfg.tool = premake[_OPTIONS.cc] end\nelseif cfg.language == \"C#\" then\nif _OPTIONS.dotnet then cfg.tool = premake[_OPTIONS.dotnet] end\nend\n\n-- deduce the target and path style from the current action/tool pairing\nlocal action = premake.actions[_ACTION]\nlocal targetstyle = action.targetstyle or \"linux\"\nif (cfg.tool) then\ntargetstyle = cfg.tool.targetstyle or targetstyle\nend\n\n-- build a unique objects directory\nlocal function buildpath(cfg, variant)\nlocal dir = path.getabsolute(path.join(cfg.location, cfg.objdir or cfg.project.objdir or \"obj\"))\nif variant > 1 and cfg.platform ~= \"Native\" then\ndir = path.join(dir, cfg.platform)\nend\nif variant > 2 then\ndir = path.join(dir, cfg.name)\nend\nif variant > 3 then\ndir = path.join(dir, cfg.project.name)\nend\nreturn dir\nend\n\nlocal function getuniquedir(thiscfg)\nlocal variant = 1\nlocal thispath = buildpath(thiscfg, variant)\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nfor _, thatcfg in pairs(prj.__configs) do\nif thiscfg ~= thatcfg then\nlocal thatpath = buildpath(thatcfg, variant)\nwhile thispath == thatpath and variant < 4 do\nvariant = variant + 1\nthispath = buildpath(thiscfg, variant)\nthatpath = buildpath(thatcfg, variant)\nend\nend\nend\nend\nend\n\nreturn thispath\nend\n\ncfg.objectsdir = path.getrelative(cfg.location, getuniquedir(cfg))\n\n-- precompute the target names and paths\ncfg.buildtarget = premake.gettarget(cfg, \"build\", targetstyle)\ncfg.linktarget  = premake.gettarget(cfg, \"link\",  targetstyle)\n\n-- translate the paths as appropriate\nlocal pathstyle = action.pathstyle or targetstyle\nif (pathstyle == \"windows\") then\ncfg.buildtarget.directory = path.translate(cfg.buildtarget.directory, \"\\\\\")\ncfg.buildtarget.fullpath  = path.translate(cfg.buildtarget.fullpath, \"\\\\\")\ncfg.linktarget.directory = path.translate(cfg.linktarget.directory, \"\\\\\")\ncfg.linktarget.fullpath  = path.translate(cfg.linktarget.fullpath, \"\\\\\")\ncfg.objectsdir = path.translate(cfg.objectsdir, \"\\\\\")\nend\nend\n\n\n\n\nfunction premake.buildconfigs()\n-- walk the object tree once and flatten the configurations\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nprj.__configs = { }\n\n-- create a project-wide \"root\" config\nprj.__configs[\"\"] = buildprojectconfig(prj)\n\n-- then one per build configuration\nfor _, cfgname in ipairs(sln.configurations) do\n-- build a platform independent config\nprj.__configs[cfgname] = buildprojectconfig(prj, cfgname)\n\n-- then one per build configuration/platform pair. Skip the native build\n-- since it is the same as the platform independent config built above\nif sln.platforms then\nfor _, pltname in ipairs(sln.platforms) do\nif pltname ~= \"Native\" then\nprj.__configs[cfgname .. \":\" .. pltname] = buildprojectconfig(prj, cfgname, pltname)\nend\nend\nend\n\nend\nend\nend\n\n-- walk it again and build the targets and unique directories\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nfor _, cfg in pairs(prj.__configs) do\nbuildtargets(cfg)\nend\nend\nend\nend\n",
	"--\n\n\n\npremake.fields = \n{\nbasedir =\n{\nkind  = \"path\",\nscope = \"container\",\n},\n\nbuildaction =\n{\nkind  = \"string\",\nscope = \"config\",\nallowed = {\n\"Compile\",\n\"Copy\",\n\"Embed\",\n\"None\"\n}\n},\n\nbuildoptions =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nconfigurations = \n{\nkind  = \"list\",\nscope = \"solution\",\n},\n\ndefines =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nexcludes =\n{\nkind  = \"filelist\",\nscope = \"config\",\n},\n\nfiles =\n{\nkind  = \"filelist\",\nscope = \"config\",\n},\n\nflags =\n{\nkind  = \"list\",\nscope = \"config\",\nisflags = true,\nallowed = {\n\"ExtraWarnings\",\n\"FatalWarnings\",\n\"Managed\",\n\"NativeWChar\",\n\"No64BitChecks\",\n\"NoEditAndContinue\",\n\"NoExceptions\",\n\"NoFramePointer\",\n\"NoImportLib\",\n\"NoManifest\",\n\"NoNativeWChar\",\n\"NoPCH\",\n\"NoRTTI\",\n\"Optimize\",\n\"OptimizeSize\",\n\"OptimizeSpeed\",\n\"SEH\",\n\"StaticRuntime\",\n\"Symbols\",\n\"Unicode\",\n\"Unsafe\",\n\"WinMain\"\n}\n},\n\nimplibdir =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\nimplibextension =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nimplibname =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nimplibprefix =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nincludedirs =\n{\nkind  = \"dirlist\",\nscope = \"config\",\n},\n\nkind =\n{\nkind  = \"string\",\nscope = \"config\",\nallowed = {\n\"ConsoleApp\",\n\"WindowedApp\",\n\"StaticLib\",\n\"SharedLib\"\n}\n},\n\nlanguage =\n{\nkind  = \"string\",\nscope = \"container\",\nallowed = {\n\"C\",\n\"C++\",\n\"C#\"\n}\n},\n\nlibdirs =\n{\nkind  = \"dirlist\",\nscope = \"config\",\n},\n\nlinkoptions =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nlinks =\n{\nkind  = \"list\",\nscope = \"config\",\nallowed = function(value)\n-- if library name contains a '/' then treat it as a path to a local file\nif value:find('/', nil, true) then\nvalue = path.getabsolute(value)\nend\nreturn value\nend\n\n},\n\nlocation =\n{\nkind  = \"path\",\nscope = \"container\",\n},\n\nobjdir =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\npchheader =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\npchsource =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\nplatforms = \n{\nkind  = \"list\",\nscope = \"solution\",\nallowed = {\n\"Native\",\n\"x32\",\n\"x64\",\n\"Universal\",\n\"Universal32\",\n\"Universal64\",\n\"Xbox360\"\n}\n},\n\npostbuildcommands =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nprebuildcommands =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nprelinkcommands =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nresdefines =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nresincludedirs =\n{\nkind  = \"dirlist\",\nscope = \"config\",\n},\n\nresoptions =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\ntargetdir =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\ntargetextension =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\ntargetname =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\ntargetprefix =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nuuid =\n{\nkind  = \"string\",\nscope = \"container\",\nallowed = function(value)\nlocal ok = true\nif (#value ~= 36) then ok = false end\nfor i=1,36 do\nlocal ch = value:sub(i,i)\nif (not ch:find(\"[ABCDEFabcdef0123456789-]\")) then ok = false end\nend\nif (value:sub(9,9) ~= \"-\")   then ok = false end\nif (value:sub(14,14) ~= \"-\") then ok = false end\nif (value:sub(19,19) ~= \"-\") then ok = false end\nif (value:sub(24,24) ~= \"-\") then ok = false end\nif (not ok) then\nreturn nil, \"invalid UUID\"\nend\nreturn value:upper()\nend\n},\n}\n\n\n\n\n\n\nlocal function checkvalue(value, allowed)\nif (allowed) then\nif (type(allowed) == \"function\") then\nreturn allowed(value)\nelse\nfor _,v in ipairs(allowed) do\nif (value:lower() == v:lower()) then\nreturn v\nend\nend\nreturn nil, \"invalid value '\" .. value .. \"'\"\nend\nelse\nreturn value\nend\nend\n\n\n\n\nfunction premake.getobject(t)\nlocal container\n\nif (t == \"container\" or t == \"solution\") then\ncontainer = premake.CurrentContainer\nelse\ncontainer = premake.CurrentConfiguration\nend\n\nif t == \"solution\" then\nif type(container) == \"project\" then\ncontainer = container.solution\nend\nif type(container) ~= \"solution\" then\ncontainer = nil\nend\nend\n\nlocal msg\nif (not container) then\nif (t == \"container\") then\nmsg = \"no active solution or project\"\nelseif (t == \"solution\") then\nmsg = \"no active solution\"\nelse\nmsg = \"no active solution, project, or configuration\"\nend\nend\n\nreturn container, msg\nend\n\n\n\n\nfunction premake.setarray(ctype, fieldname, value, allowed)\nlocal container, err = premake.getobject(ctype)\nif (not container) then\nerror(err, 4)\nend\n\nif (not container[fieldname]) then\ncontainer[fieldname] = { }\nend\n\nlocal function doinsert(value, depth)\nif (type(value) == \"table\") then\nfor _,v in ipairs(value) do\ndoinsert(v, depth + 1)\nend\nelse\nvalue, err = checkvalue(value, allowed)\nif (not value) then\nerror(err, depth)\nend\ntable.insert(container[fieldname], value)\nend\nend\n\nif (value) then\ndoinsert(value, 5)\nend\n\nreturn container[fieldname]\nend\n\n\n\n\nlocal function domatchedarray(ctype, fieldname, value, matchfunc)\nlocal result = { }\n\nfunction makeabsolute(value)\nif (type(value) == \"table\") then\nfor _,item in ipairs(value) do\nmakeabsolute(item)\nend\nelse\nif value:find(\"*\") then\nmakeabsolute(matchfunc(value))\nelse\ntable.insert(result, path.getabsolute(value))\nend\nend\nend\n\nmakeabsolute(value)\nreturn premake.setarray(ctype, fieldname, result)\nend\n\nfunction premake.setdirarray(ctype, fieldname, value)\nreturn domatchedarray(ctype, fieldname, value, os.matchdirs)\nend\n\nfunction premake.setfilearray(ctype, fieldname, value)\nreturn domatchedarray(ctype, fieldname, value, os.matchfiles)\nend\n\n\n\n\nfunction premake.setstring(ctype, fieldname, value, allowed)\n-- find the container for this value\nlocal container, err = premake.getobject(ctype)\nif (not container) then\nerror(err, 4)\nend\n\n-- if a value was provided, set it\nif (value) then\nvalue, err = checkvalue(value, allowed)\nif (not value) then \nerror(err, 4)\nend\n\ncontainer[fieldname] = value\nend\n\nreturn container[fieldname]\nend\n\n\n\n\nlocal function accessor(name, value)\nlocal kind    = premake.fields[name].kind\nlocal scope   = premake.fields[name].scope\nlocal allowed = premake.fields[name].allowed\n\nif (kind == \"string\" or kind == \"path\" and value) then\nif type(value) ~= \"string\" then\nerror(\"string value expected\", 3)\nend\nend\n\nif (kind == \"string\") then\nreturn premake.setstring(scope, name, value, allowed)\nelseif (kind == \"path\") then\nif value then value = path.getabsolute(value) end\nreturn premake.setstring(scope, name, value)\nelseif (kind == \"list\") then\nreturn premake.setarray(scope, name, value, allowed)\nelseif (kind == \"dirlist\") then\nreturn premake.setdirarray(scope, name, value)\nelseif (kind == \"filelist\") then\nreturn premake.setfilearray(scope, name, value)\nend\nend\n\n\n\n\nfor name,_ in pairs(premake.fields) do\n_G[name] = function(value)\nreturn accessor(name, value)\nend\nend\n\n\n\n\nfunction configuration(keywords)\nif not keywords then\nreturn premake.CurrentConfiguration\nend\n\nlocal container, err = premake.getobject(\"container\")\nif (not container) then\nerror(err, 2)\nend\n\nlocal cfg = { }\ntable.insert(container.blocks, cfg)\npremake.CurrentConfiguration = cfg\n\n-- create a keyword list using just the indexed keyword items\ncfg.keywords = { }\nfor _, word in ipairs(table.join({}, keywords)) do\ntable.insert(cfg.keywords, premake.escapekeyword(word))\nend\n\n-- if file patterns are specified, convert them to Lua patterns and add them too\nif keywords.files then\nfor _, pattern in ipairs(table.join({}, keywords.files)) do\npattern = pattern:gsub(\"%.\", \"%%.\")\nif pattern:find(\"**\", nil, true) then\npattern = pattern:gsub(\"%*%*\", \".*\")\nelse\npattern = pattern:gsub(\"%*\", \"[^/]*\")\nend\ntable.insert(cfg.keywords, \"^\" .. pattern .. \"$\")\nend\nend\n\n-- initialize list-type fields to empty tables\nfor name, field in pairs(premake.fields) do\nif (field.kind ~= \"string\" and field.kind ~= \"path\") then\ncfg[name] = { }\nend\nend\n\nreturn cfg\nend\n\n\nfunction project(name)\nif not name then\nreturn iif(type(premake.CurrentContainer) == \"project\", premake.CurrentContainer, nil)\nend\n\n-- identify the parent solution\nlocal sln\nif (type(premake.CurrentContainer) == \"project\") then\nsln = premake.CurrentContainer.solution\nelse\nsln = premake.CurrentContainer\nend\nif (type(sln) ~= \"solution\") then\nerror(\"no active solution\", 2)\nend\n\n-- if this is a new project, create it\npremake.CurrentContainer = sln.projects[name]\nif (not premake.CurrentContainer) then\nlocal prj = { }\npremake.CurrentContainer = prj\n\n-- add to master list keyed by both name and index\ntable.insert(sln.projects, prj)\nsln.projects[name] = prj\n\n-- attach a type\nsetmetatable(prj, {\n__type = \"project\",\n})\n\nprj.solution       = sln\nprj.name           = name\nprj.basedir        = os.getcwd()\nprj.location       = prj.basedir\nprj.uuid           = os.uuid()\nprj.blocks         = { }\nend\n\n-- add an empty, global configuration to the project\nconfiguration { }\n\nreturn premake.CurrentContainer\nend\n\n\nfunction solution(name)\nif not name then\nif type(premake.CurrentContainer) == \"project\" then\nreturn premake.CurrentContainer.solution\nelse\nreturn premake.CurrentContainer\nend\nend\n\npremake.CurrentContainer = _SOLUTIONS[name]\nif (not premake.CurrentContainer) then\nlocal sln = { }\npremake.CurrentContainer = sln\n\n-- add to master list keyed by both name and index\ntable.insert(_SOLUTIONS, sln)\n_SOLUTIONS[name] = sln\n\n-- attach a type\nsetmetatable(sln, { \n__type=\"solution\"\n})\n\nsln.name           = name\nsln.location       = os.getcwd()\nsln.projects       = { }\nsln.blocks         = { }\nsln.configurations = { }\nend\n\n-- add an empty, global configuration\nconfiguration { }\n\nreturn premake.CurrentContainer\nend\n\n\n",
	"--\n\n\nlocal requiredactionfields =\n{\n\"description\",\n\"trigger\",\n}\n\nlocal requiredoptionfields = \n{\n\"description\",\n\"trigger\"\n}\n\n\n\nfunction newaction(a)\n-- some sanity checking\nlocal missing\nfor _, field in ipairs(requiredactionfields) do\nif (not a[field]) then\nmissing = field\nend\nend\n\nif (missing) then\nerror(\"action needs a \" .. missing, 2)\nend\n\n-- add it to the master list\npremake.actions[a.trigger] = a\nend\n\n\n\n\nfunction newoption(opt)\n-- some sanity checking\nlocal missing\nfor _, field in ipairs(requiredoptionfields) do\nif (not opt[field]) then\nmissing = field\nend\nend\n\nif (missing) then\nerror(\"action needs a \" .. missing, 2)\nend\n\n-- add it to the master list\npremake.options[opt.trigger] = opt\nend\n\n\n\n\nnewoption \n{\ntrigger     = \"cc\",\nvalue       = \"compiler\",\ndescription = \"Choose a C/C++ compiler set\",\nallowed = {\n{ \"gcc\", \"GNU GCC compiler (gcc/g++)\" },\n{ \"ow\",  \"OpenWatcom compiler\"        },\n}\n}\n\nnewoption\n{\ntrigger     = \"dotnet\",\nvalue       = \"value\",\ndescription = \"Choose a .NET compiler set\",\nallowed = {\n{ \"ms\",      \"Microsoft .NET (csc)\" },\n{ \"mono\",    \"Novell Mono (mcs)\"    },\n{ \"pnet\",    \"Portable.NET (cscc)\"  },\n}\n}\n\nnewoption\n{\ntrigger     = \"file\",\nvalue       = \"filename\",\ndescription = \"Process the specified Premake script file\"\n}\n\nnewoption\n{\ntrigger     = \"help\",\ndescription = \"Display this information\"\n}\n\nnewoption\n{\ntrigger     = \"os\",\nvalue       = \"value\",\ndescription = \"Generate files for a different operating system\",\nallowed = {\n{ \"bsd\",      \"OpenBSD, NetBSD, or FreeBSD\" },\n{ \"linux\",    \"Linux\" },\n{ \"macosx\",   \"Apple Mac OS X\" },\n{ \"windows\",  \"Microsoft Windows\" },\n}\n}\n\nnewoption\n{\ntrigger     = \"scripts\",\nvalue       = \"path\",\ndescription = \"Search for additional scripts on the given path\"\n}\n\nnewoption\n{\ntrigger     = \"version\",\ndescription = \"Display version information\"\n}\n",
	"--\n\n\npremake.csc = { }\n\n\n\nlocal flags =\n{\nFatalWarning   = \"/warnaserror\",\nOptimize       = \"/optimize\",\nOptimizeSize   = \"/optimize\",\nOptimizeSpeed  = \"/optimize\",\nSymbols        = \"/debug\",\nUnsafe         = \"/unsafe\"\n}\n\n\n\nfunction premake.csc.getbuildaction(fcfg)\nlocal ext = path.getextension(fcfg.name):lower()\nif fcfg.buildaction == \"Compile\" or ext == \".cs\" then\nreturn \"Compile\"\nelseif fcfg.buildaction == \"Embed\" or ext == \".resx\" then\nreturn \"EmbeddedResource\"\nelseif fcfg.buildaction == \"Copy\" or ext == \".asax\" or ext == \".aspx\" then\nreturn \"Content\"\nelse\nreturn \"None\"\nend\nend\n\n\n\n\nfunction premake.csc.getcompilervar(cfg)\nif (_OPTIONS.dotnet == \"ms\") then\nreturn \"csc\"\nelseif (_OPTIONS.dotnet == \"mono\") then\nreturn \"gmcs\"\nelse\nreturn \"cscc\"\nend\nend\n\n\n\n\nfunction premake.csc.getflags(cfg)\nlocal result = table.translate(cfg.flags, flags)\nreturn result\nend\n\n\n\n\nfunction premake.csc.getkind(cfg)\nif (cfg.kind == \"ConsoleApp\") then\nreturn \"Exe\"\nelseif (cfg.kind == \"WindowedApp\") then\nreturn \"WinExe\"\nelseif (cfg.kind == \"SharedLib\") then\nreturn \"Library\"\nend\nend",
	"--\n\n\npremake.gcc = { }\npremake.targetstyle = \"linux\"\n\n\n\nlocal cflags =\n{\nExtraWarnings  = \"-Wall\",\nFatalWarnings  = \"-Werror\",\nNoFramePointer = \"-fomit-frame-pointer\",\nOptimize       = \"-O2\",\nOptimizeSize   = \"-Os\",\nOptimizeSpeed  = \"-O3\",\nSymbols        = \"-g\",\n}\n\nlocal cxxflags =\n{\nNoExceptions   = \"-fno-exceptions\",\nNoRTTI         = \"-fno-rtti\",\n}\n\n\n\npremake.gcc.platforms = \n{\nNative = { \nsuffix   = \"\",\ncppflags = \"-MMD\", \nflags    = \"\" ,\nldflags  = \"\",\n},\nx32 = { \nsuffix   = \"32\",\ncppflags = \"-MMD\", \nflags    = \"-m32\",\nldflags  = \"-L/usr/lib32\", \n},\nx64 = { \nsuffix   = \"64\",\ncppflags = \"-MMD\",\nflags    = \"-m64\",\nldflags  = \"-L/usr/lib64\",\n},\nUniversal = { \nsuffix   = \"univ\",\ncppflags = \"\",\nflags    = \"-arch i386 -arch x86_64 -arch ppc -arch ppc64\",\nldflags  = \"\",\n},\nUniversal32 = { \nsuffix   = \"univ32\",\ncppflags = \"\",\nflags    = \"-arch i386 -arch ppc\",\nldflags  = \"\",\n},\nUniversal64 = { \nsuffix   = \"univ64\",\ncppflags = \"\",\nflags    = \"-arch x86_64 -arch ppc64\",\nldflags  = \"\",\n},\n}\n\n\n\n\nfunction premake.gcc.getcppflags(cfg)\nreturn premake.gcc.platforms[cfg.platform].cppflags\nend\n\nfunction premake.gcc.getcflags(cfg)\nlocal result = table.translate(cfg.flags, cflags)\nif (cfg.kind == \"SharedLib\" and not os.is(\"windows\")) then\ntable.insert(result, \"-fPIC\")\nend\ntable.insert(result, premake.gcc.platforms[cfg.platform].flags)\nreturn result\nend\n\nfunction premake.gcc.getcxxflags(cfg)\nlocal result = table.translate(cfg.flags, cxxflags)\nreturn result\nend\n\n\n\n\nfunction premake.gcc.getldflags(cfg)\nlocal result = { }\n\nif (cfg.kind == \"SharedLib\") then\nif os.is(\"macosx\") then\nresult = table.join(result, { \"-dynamiclib\", \"-flat_namespace\" })\nelse\ntable.insert(result, \"-shared\")\nend\n\n-- create import library for DLLs under Windows\nif (os.is(\"windows\") and not cfg.flags.NoImportLib) then\ntable.insert(result, '-Wl,--out-implib=\"'..premake.gettarget(cfg, \"link\", \"linux\").fullpath..'\"')\nend\nend\n\nif (os.is(\"windows\") and cfg.kind == \"WindowedApp\") then\ntable.insert(result, \"-mwindows\")\nend\n\n-- OS X has a bug, see http://lists.apple.com/archives/Darwin-dev/2006/Sep/msg00084.html\nif (not cfg.flags.Symbols) then\nif (os.is(\"macosx\")) then\ntable.insert(result, \"-Wl,-x\")\nelse\ntable.insert(result, \"-s\")\nend\nend\n\ntable.insert(result, premake.gcc.platforms[cfg.platform].flags)\ntable.insert(result, premake.gcc.platforms[cfg.platform].ldflags)\n\nreturn result\nend\n\n\n\nfunction premake.gcc.getlinkflags(cfg)\nlocal result = { }\nfor _, value in ipairs(premake.getlinks(cfg, \"all\", \"directory\")) do\ntable.insert(result, '-L' .. _MAKE.esc(value))\nend\nfor _, value in ipairs(premake.getlinks(cfg, \"all\", \"basename\")) do\ntable.insert(result, '-l' .. _MAKE.esc(value))\nend\nreturn result\nend\n\n\n\n\nfunction premake.gcc.getdefines(defines)\nlocal result = { }\nfor _,def in ipairs(defines) do\ntable.insert(result, '-D' .. def)\nend\nreturn result\nend\n\n\n\n\nfunction premake.gcc.getincludedirs(includedirs)\nlocal result = { }\nfor _,dir in ipairs(includedirs) do\ntable.insert(result, \"-I\" .. _MAKE.esc(dir))\nend\nreturn result\nend\n",
	"--\n\npremake.ow = { }\npremake.ow.targetstyle = \"windows\"\n\n\n\nlocal cflags =\n{\nExtraWarnings  = \"-wx\",\nFatalWarning   = \"-we\",\nOptimize       = \"-ox\",\nOptimizeSize   = \"-os\",\nOptimizeSpeed  = \"-ot\",\nSymbols        = \"-d2\",\n}\n\nlocal cxxflags =\n{\nNoExceptions   = \"-xd\",\nNoRTTI         = \"-xr\",\n}\n\n\n\n\npremake.ow.platforms = \n{\nNative = { suffix=\"\", cflags=\"\" },\n}\n\n\n\n\nfunction premake.ow.getcppflags(cfg)\nreturn \"\"\nend\n\nfunction premake.ow.getcflags(cfg)\nlocal result = table.translate(cfg.flags, cflags)\nif (cfg.flags.Symbols) then\ntable.insert(result, \"-hw\")   -- Watcom debug format for Watcom debugger\nend\nreturn result\nend\n\nfunction premake.ow.getcxxflags(cfg)\nlocal result = table.translate(cfg.flags, cxxflags)\nreturn result\nend\n\n\n\n\nfunction premake.ow.getldflags(cfg)\nlocal result = { }\n\nif (cfg.flags.Symbols) then\ntable.insert(result, \"op symf\")\nend\n\nreturn result\nend\n\n\n\nfunction premake.ow.getlinkflags(cfg)\nlocal result = { }\nreturn result\nend\n\n\n\n\nfunction premake.ow.getdefines(defines)\nlocal result = { }\nfor _,def in ipairs(defines) do\ntable.insert(result, '-D' .. def)\nend\nreturn result\nend\n\n\n\n\nfunction premake.ow.getincludedirs(includedirs)\nlocal result = { }\nfor _,dir in ipairs(includedirs) do\ntable.insert(result, '-I \"' .. dir .. '\"')\nend\nreturn result\nend\n\n",
	"--\n\n\n\nfunction premake.checkoptions()\nfor key, value in pairs(_OPTIONS) do\n-- is this a valid option?\nlocal opt = premake.options[key]\nif (not opt) then\nreturn false, \"invalid option '\" .. key .. \"'\"\nend\n\n-- does it need a value?\nif (opt.value and value == \"\") then\nreturn false, \"no value specified for option '\" .. key .. \"'\"\nend\n\n-- is the value allowed?\nif (opt.allowed) then\nfor _, match in ipairs(opt.allowed) do\nif (match[1] == value) then return true end\nend\nreturn false, \"invalid value '\" .. value .. \"' for option '\" .. key .. \"'\"\nend\nend\nreturn true\nend\n\n\n\n\nfunction premake.checkprojects()\nlocal action = premake.actions[_ACTION]\n\nfor _, sln in ipairs(_SOLUTIONS) do\n\n-- every solution must have at least one project\nif (#sln.projects == 0) then\nreturn nil, \"solution '\" .. sln.name .. \"' needs at least one project\"\nend\n\n-- every solution must provide a list of configurations\nif (#sln.configurations == 0) then\nreturn nil, \"solution '\" .. sln.name .. \"' needs configurations\"\nend\n\nfor prj in premake.eachproject(sln) do\n\n-- every project must have a language\nif (not prj.language) then\nreturn nil, \"project '\" ..prj.name .. \"' needs a language\"\nend\n\n-- and the action must support it\nif (action.valid_languages) then\nif (not table.contains(action.valid_languages, prj.language)) then\nreturn nil, \"the \" .. action.shortname .. \" action does not support \" .. prj.language .. \" projects\"\nend\nend\n\nfor cfg in premake.eachconfig(prj) do\n\n-- every config must have a kind\nif (not cfg.kind) then\nreturn nil, \"project '\" ..prj.name .. \"' needs a kind in configuration '\" .. cfgname .. \"'\"\nend\n\n-- and the action must support it\nif (action.valid_kinds) then\nif (not table.contains(action.valid_kinds, cfg.kind)) then\nreturn nil, \"the \" .. action.shortname .. \" action does not support \" .. cfg.kind .. \" projects\"\nend\nend\n\nend\nend\nend\nreturn true\nend\n\n\n\nfunction premake.checktools()\nlocal action = premake.actions[_ACTION]\nif (not action.valid_tools) then \nreturn true \nend\n\nfor tool, values in pairs(action.valid_tools) do\nif (_OPTIONS[tool]) then\nif (not table.contains(values, _OPTIONS[tool])) then\nreturn nil, \"the \" .. action.shortname .. \" action does not support /\" .. tool .. \"=\" .. _OPTIONS[tool] .. \" (yet)\"\nend\nelse\n_OPTIONS[tool] = values[1]\nend\nend\n\nreturn true\nend\n",
	"--\n\n\nfunction premake.showhelp()\n\n-- sort the lists of actions and options into alphabetical order\nactions = { }\nfor name,_ in pairs(premake.actions) do table.insert(actions, name) end\ntable.sort(actions)\n\noptions = { }\nfor name,_ in pairs(premake.options) do table.insert(options, name) end\ntable.sort(options)\n\n\n-- display the basic usage\nprintf(\"Premake %s, a build script generator\", _PREMAKE_VERSION)\nprintf(_PREMAKE_COPYRIGHT)\nprintf(\"%s %s\", _VERSION, _COPYRIGHT)\nprintf(\"\")\nprintf(\"Usage: premake4 [options] action [arguments]\")\nprintf(\"\")\n\n\n-- display all options\nprintf(\"OPTIONS\")\nprintf(\"\")\nfor _,name in ipairs(options) do\nlocal opt = premake.options[name]\nlocal trigger = opt.trigger\nlocal description = opt.description\n\nif (opt.value) then trigger = trigger .. \"=\" .. opt.value end\nif (opt.allowed) then description = description .. \"; one of:\" end\n\nprintf(\" --%-15s %s\", trigger, description) \nif (opt.allowed) then\ntable.sort(opt.allowed, function(a,b) return a[1] < b[1] end)\nfor _, value in ipairs(opt.allowed) do\nprintf(\"     %-14s %s\", value[1], value[2])\nend\nend\nprintf(\"\")\nend\n\n-- display all actions\nprintf(\"ACTIONS\")\nprintf(\"\")\nfor _,name in ipairs(actions) do\nprintf(\" %-17s %s\", name, premake.actions[name].description)\nend\nprintf(\"\")\n\n\n-- see more\nprintf(\"For additional information, see http://industriousone.com/premake\")\n\nend\n\n\n",
	"--\n\nfunction premake.make_solution(sln)\n-- create a shortcut to the compiler interface\nlocal cc = premake[_OPTIONS.cc]\n\n-- build a list of supported target platforms that also includes a generic build\nlocal platforms = premake.filterplatforms(sln, cc.platforms, \"Native\")\n\n-- write a header showing the build options\nlocal cfgpairs = { }\nfor _, platform in ipairs(platforms) do\nfor _, cfg in ipairs(sln.configurations) do\ntable.insert(cfgpairs, cfg .. cc.platforms[platform].suffix)\nend\nend\n_p('# %s solution makefile autogenerated by Premake', premake.actions[_ACTION].shortname)\n_p('# Usage: make [ config=config_name ]')\n_p('# Where {config_name} is one of: %s.', table.implode(cfgpairs, '\"', '\"', ', '):lower())\n_p('')\n\n-- set a default configuration\n_p('ifndef config')\n_p('  config=%s%s', _MAKE.esc(sln.configurations[1]:lower()), cc.platforms[platforms[1]].suffix)\n_p('endif')\n_p('export config')\n_p('')\n\n-- list the projects included in the solution\n_p('PROJECTS := %s', table.concat(_MAKE.esc(table.extract(sln.projects, \"name\")), \" \"))\n_p('')\n_p('.PHONY: all clean $(PROJECTS)')\n_p('')\n_p('all: $(PROJECTS)')\n_p('')\n\n-- write the project build rules\nfor _, prj in ipairs(sln.projects) do\n\n-- before each project rule, build a list of dependencies for the project. If any of\n-- these dependencies change, the project needs to be rebuilt\nfor _, platform in ipairs(platforms) do\nfor cfg in premake.eachconfig(prj, platform) do\n_p('ifeq ($(config),%s%s)', _MAKE.esc(cfg.name:lower()), cc.platforms[platform].suffix)\n_p('  DEPENDENCIES := %s', table.concat(_MAKE.esc(table.extract(premake.getdependencies(cfg), \"name\")), \" \"))\n_p('endif')\nend\nend\n_p('')\n\n_p('%s: ${DEPENDENCIES}', _MAKE.esc(prj.name))\n_p('\\t@echo ==== Building %s ====', prj.name)\n_p('\\t@${MAKE} --no-print-directory -C %s -f %s', _MAKE.esc(path.getrelative(sln.location, prj.location)), _MAKE.esc(_MAKE.getmakefilename(prj, true)))\n_p('')\nend\n\n-- clean rules\n_p('clean:')\nfor _ ,prj in ipairs(sln.projects) do\n_p('\\t@${MAKE} --no-print-directory -C %s -f %s clean', _MAKE.esc(path.getrelative(sln.location, prj.location)), _MAKE.esc(_MAKE.getmakefilename(prj, true)))\nend\n_p('')\n\nend\n",
	"--\n\nfunction premake.make_cpp(prj)\n-- create a shortcut to the compiler interface\nlocal cc = premake[_OPTIONS.cc]\n\n-- build a list of supported target platforms that also includes a generic build\nlocal platforms = premake.filterplatforms(prj.solution, cc.platforms, \"Native\")\n\n-- write a quick header\n_p('# %s project makefile autogenerated by Premake', premake.actions[_ACTION].shortname)\n\n-- set up the environment\n_p('ifndef config')\n_p('  config=%s%s', _MAKE.esc(prj.configurations[1]:lower()), cc.platforms[platforms[1]].suffix)\n_p('endif')\n_p('')\n\n_p('ifndef verbose')\n_p('  SILENT = @')\n_p('endif')\n_p('')\n\n-- list the configurations\nfor _, platform in ipairs(platforms) do\nfor cfg in premake.eachconfig(prj, platform) do\n_p('ifeq ($(config),%s%s)', _MAKE.esc(cfg.name:lower()), cc.platforms[platform].suffix)\n_p('  TARGETDIR  = %s', _MAKE.esc(cfg.buildtarget.directory))\n_p('  TARGET     = $(TARGETDIR)/%s', _MAKE.esc(cfg.buildtarget.name))\n_p('  OBJDIR     = %s', _MAKE.esc(cfg.objectsdir))\n_p('  DEFINES   += %s', table.concat(cc.getdefines(cfg.defines), \" \"))\n_p('  INCLUDES  += %s', table.concat(cc.getincludedirs(cfg.includedirs), \" \"))\n_p('  CPPFLAGS  += %s $(DEFINES) $(INCLUDES)', cc.getcppflags(cfg))\n_p('  CFLAGS    += $(CPPFLAGS) $(ARCH) %s', table.concat(table.join(cc.getcflags(cfg), cfg.buildoptions), \" \"))\n_p('  CXXFLAGS  += $(CFLAGS) %s', table.concat(cc.getcxxflags(cfg), \" \"))\n_p('  LDFLAGS   += %s', table.concat(table.join(cc.getldflags(cfg), cc.getlinkflags(cfg), cfg.linkoptions), \" \"))\n_p('  RESFLAGS  += $(DEFINES) $(INCLUDES) %s', table.concat(table.join(cc.getdefines(cfg.resdefines), cc.getincludedirs(cfg.resincludedirs), cfg.resoptions), \" \"))\n_p('  LDDEPS    += %s', table.concat(_MAKE.esc(premake.getlinks(cfg, \"siblings\", \"fullpath\")), \" \"))\n\nif cfg.kind == \"StaticLib\" then\n_p('  LINKCMD    = ar -rcs $(TARGET) $(OBJECTS)')\nelse\n_p('  LINKCMD    = $(%s) -o $(TARGET) $(OBJECTS) $(LDFLAGS) $(RESOURCES) $(ARCH)', iif(cfg.language == \"C\", \"CC\", \"CXX\"))\nend\n\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p('\\t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('endif')\n_p('')\nend\nend\n\n-- list intermediate files\n_p('OBJECTS := \\\\')\nfor _, file in ipairs(prj.files) do\nif path.iscppfile(file) then\n_p('\\t$(OBJDIR)/%s.o \\\\', _MAKE.esc(path.getbasename(file)))\nend\nend\n_p('')\n \n_p('RESOURCES := \\\\')\nfor _, file in ipairs(prj.files) do\nif path.isresourcefile(file) then\n_p('\\t$(OBJDIR)/%s.res \\\\', _MAKE.esc(path.getbasename(file)))\nend\nend\n_p('')\n \n-- set up support commands like mkdir, rmdir, etc. based on the shell\n_p('SHELLTYPE := msdos')\n_p('ifeq (,$(ComSpec)$(COMSPEC))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(SHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('   define MKDIR_RULE')\n_p('\\t@echo Creating $@')\n_p('\\t$(SILENT) mkdir -p $@')\n_p('   endef')\n_p('else')\n_p('   define MKDIR_RULE')\n_p('\\t@echo Creating $@')\n_p('\\t$(SILENT) mkdir $(subst /,\\\\\\\\,$@)')\n_p('   endef')\n_p('endif')\n_p('')\n\n-- main build rule(s)\n_p('.PHONY: clean prebuild prelink')\n_p('')\n\nif os.is(\"MacOSX\") and prj.kind == \"WindowedApp\" then\n_p('all: $(TARGETDIR) $(OBJDIR) prebuild $(OBJECTS) $(RESOURCES) prelink $(TARGET) $(dir $(TARGETDIR))PkgInfo $(dir $(TARGETDIR))Info.plist')\nelse\n_p('all: $(TARGETDIR) $(OBJDIR) prebuild $(OBJECTS) $(RESOURCES) prelink $(TARGET)')\nend\n_p('')\n\n_p('$(TARGET): $(OBJECTS) $(LDDEPS) $(RESOURCES)')\n_p('\\t@echo Linking %s', prj.name)\n_p('\\t@$(LINKCMD)')\n_p('\\t$(POSTBUILDCMDS)')\n_p('')\n\n-- create destination directories\n_p('$(TARGETDIR):')\n_p('\\t$(MKDIR_RULE)')\n_p('')\n\n_p('$(OBJDIR):')\n_p('\\t$(MKDIR_RULE)')\n_p('')\n\n-- Mac OS X specific targets\nif os.is(\"MacOSX\") and prj.kind == \"WindowedApp\" then\n_p('$(dir $(TARGETDIR))PkgInfo:')\n_p('$(dir $(TARGETDIR))Info.plist:')\n_p('')\nend\n\n-- clean target\n_p('clean:')\n_p('\\t@echo Cleaning %s', prj.name)\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('\\t$(SILENT) rm -f  $(TARGET)')\n_p('\\t$(SILENT) rm -rf $(OBJDIR)')\n_p('else')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(TARGET)) del $(subst /,\\\\\\\\,$(TARGET))')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\\\\\,$(OBJDIR))')\n_p('endif')\n_p('')\n\n-- custom build step targets\n_p('prebuild:')\n_p('\\t$(PREBUILDCMDS)')\n_p('')\n\n_p('prelink:')\n_p('\\t$(PRELINKCMDS)')\n_p('')\n\n-- per-file rules\nfor _, file in ipairs(prj.files) do\nif path.iscppfile(file) then\n_p('$(OBJDIR)/%s.o: %s', _MAKE.esc(path.getbasename(file)), _MAKE.esc(file))\n_p('\\t@echo $(notdir $<)')\nif (path.iscfile(file)) then\n_p('\\t$(SILENT) $(CC) $(CFLAGS) -o $@ -c $<')\nelse\n_p('\\t$(SILENT) $(CXX) $(CXXFLAGS) -o $@ -c $<')\nend\nelseif (path.getextension(file) == \".rc\") then\n_p('$(OBJDIR)/%s.res: %s', _MAKE.esc(path.getbasename(file)), _MAKE.esc(file))\n_p('\\t@echo $(notdir $<)')\n_p('\\t$(SILENT) windres $< -O coff -o $@ $(RESFLAGS)')\nend\nend\n_p('')\n\n-- include the dependencies, built by GCC (with the -MMD flag)\n_p('-include $(OBJECTS:%%.o=%%.d)')\nend\n\n\n\nfunction premake.gmake_cpp_config(cfg)\nlocal cc = premake[_OPTIONS.cc]\nlocal platform = cc.platforms[cfg.platform or \"Native\"].suffix\n\n_p('ifeq ($(config),%s%s)', _MAKE.esc(cfg.name:lower()), platform)\n_p('  TARGETDIR  = %s', _MAKE.esc(cfg.buildtarget.directory))\n_p('  TARGET     = $(TARGETDIR)/%s', _MAKE.esc(cfg.buildtarget.name))\n_p('  OBJDIR     = %s', _MAKE.esc(cfg.objectsdir))\n_p('  DEFINES   += %s', table.concat(cc.getdefines(cfg.defines), \" \"))\n_p('  INCLUDES  += %s', table.concat(cc.getincludedirs(cfg.includedirs), \" \"))\n_p('  CPPFLAGS  += %s $(DEFINES) $(INCLUDES)', cc.getcppflags(cfg))\n_p('  CFLAGS    += $(CPPFLAGS) $(ARCH) %s', table.concat(table.join(cc.getcflags(cfg), cfg.buildoptions), \" \"))\n_p('  CXXFLAGS  += $(CFLAGS) %s', table.concat(cc.getcxxflags(cfg), \" \"))\n_p('  LDFLAGS   += %s', table.concat(table.join(cc.getldflags(cfg), cc.getlinkflags(cfg), cfg.linkoptions), \" \"))\n_p('  RESFLAGS  += $(DEFINES) $(INCLUDES) %s', table.concat(table.join(cc.getdefines(cfg.resdefines), cc.getincludedirs(cfg.resincludedirs), cfg.resoptions), \" \"))\n_p('  LDDEPS    += %s', table.concat(_MAKE.esc(premake.getlinks(cfg, \"siblings\", \"fullpath\")), \" \"))\n\nif cfg.kind == \"StaticLib\" then\n_p('  LINKCMD    = ar -rcs $(TARGET) $(OBJECTS)')\nelse\n_p('  LINKCMD    = $(%s) -o $(TARGET) $(OBJECTS) $(LDFLAGS) $(RESOURCES) $(ARCH)', iif(cfg.language == \"C\", \"CC\", \"CXX\"))\nend\n\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p('\\t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('endif')\n_p('')\nend\n",
	"--\n\n\nlocal function getresourcefilename(cfg, fname)\nif path.getextension(fname) == \".resx\" then\n    local name = cfg.buildtarget.basename .. \".\"\n    local dir = path.getdirectory(fname)\n    if dir ~= \".\" then \nname = name .. path.translate(dir, \".\") .. \".\"\nend\nreturn \"$(OBJDIR)/\" .. name .. path.getbasename(fname) .. \".resources\"\nelse\nreturn fname\nend\nend\n\n\n\nfunction premake.make_csharp(prj)\nlocal csc = premake.csc\n\n-- Do some processing up front: build a list of configuration-dependent libraries.\n-- Libraries that are built to a location other than $(TARGETDIR) will need to\n-- be copied so they can be found at runtime.\nlocal cfglibs = { }\nlocal cfgpairs = { }\nlocal anycfg\nfor cfg in premake.eachconfig(prj) do\nanycfg = cfg\ncfglibs[cfg] = premake.getlinks(cfg, \"siblings\", \"fullpath\")\ncfgpairs[cfg] = { }\nfor _, fname in ipairs(cfglibs[cfg]) do\nif path.getdirectory(fname) ~= cfg.buildtarget.directory then\ncfgpairs[cfg][\"$(TARGETDIR)/\"..path.getname(fname)] = fname\nend\nend\nend\n\n-- sort the files into categories, based on their build action\nlocal sources = {}\nlocal embedded = { }\nlocal copypairs = { }\n\nfor fcfg in premake.eachfile(prj) do\nlocal action = csc.getbuildaction(fcfg)\nif action == \"Compile\" then\ntable.insert(sources, fcfg.name)\nelseif action == \"EmbeddedResource\" then\ntable.insert(embedded, fcfg.name)\nelseif action == \"Content\" then\ncopypairs[\"$(TARGETDIR)/\"..path.getname(fcfg.name)] = fcfg.name\nelseif path.getname(fcfg.name):lower() == \"app.config\" then\ncopypairs[\"$(TARGET).config\"] = fcfg.name\nend\nend\n\n-- Any assemblies that are on the library search paths should be copied\n-- to $(TARGETDIR) so they can be found at runtime\nlocal paths = table.translate(prj.libdirs, function(v) return path.join(prj.basedir, v) end)\npaths = table.join({prj.basedir}, paths)\nfor _, libname in ipairs(premake.getlinks(prj, \"system\", \"fullpath\")) do\nlocal libdir = os.pathsearch(libname..\".dll\", unpack(paths))\nif (libdir) then\nlocal target = \"$(TARGETDIR)/\"..path.getname(libname)\nlocal source = path.getrelative(prj.basedir, path.join(libdir, libname))..\".dll\"\ncopypairs[target] = source\nend\nend\n\n-- end of preprocessing --\n\n\n-- set up the environment\n_p('# %s project makefile autogenerated by Premake', premake.actions[_ACTION].shortname)\n_p('')\n\n_p('ifndef config')\n_p('  config=%s', _MAKE.esc(prj.configurations[1]:lower()))\n_p('endif')\n_p('')\n\n_p('ifndef verbose')\n_p('  SILENT = @')\n_p('endif')\n_p('')\n\n_p('ifndef CSC')\n_p('  CSC=%s', csc.getcompilervar(prj))\n_p('endif')\n_p('')\n\n_p('ifndef RESGEN')\n_p('  RESGEN=resgen')\n_p('endif')\n_p('')\n\n-- Platforms aren't support for .NET projects, but I need the ability to match\n-- the buildcfg:platform identifiers with a block of settings. So enumerate the\n-- pairs the same way I do for C/C++ projects, but always use the generic settings\nlocal platforms = premake.filterplatforms(prj.solution, premake[_OPTIONS.cc].platforms)\ntable.insert(platforms, 1, \"\")\n\n-- write the configuration blocks\nfor cfg in premake.eachconfig(prj) do\n_p('ifneq (,$(findstring %s,$(config)))', _MAKE.esc(cfg.name:lower()))\n_p('  TARGETDIR  := %s', _MAKE.esc(cfg.buildtarget.directory))\n_p('  OBJDIR     := %s', _MAKE.esc(cfg.objectsdir))\n_p('  DEPENDS    := %s', table.concat(_MAKE.esc(premake.getlinks(cfg, \"dependencies\", \"fullpath\")), \" \"))\n_p('  REFERENCES := %s', table.implode(_MAKE.esc(cfglibs[cfg]), \"/r:\", \"\", \" \"))\n_p('  FLAGS      += %s %s', table.concat(csc.getflags(cfg), \" \"), table.implode(cfg.defines, \"/d:\", \"\", \" \"))\n\n_p('  define PREBUILDCMDS')\nif #cfg.prebuildcommands > 0 then\n_p('\\t@echo Running pre-build commands')\n_p('\\t%s', table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('  define PRELINKCMDS')\nif #cfg.prelinkcommands > 0 then\n_p('\\t@echo Running pre-link commands')\n_p('\\t%s', table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('  define POSTBUILDCMDS')\nif #cfg.postbuildcommands > 0 then\n_p('\\t@echo Running post-build commands')\n_p('\\t%s', table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\"))\nend\n_p('  endef')\n\n_p('endif')\n_p('')\nend\n\n-- set project level values\n_p('# To maintain compatibility with VS.NET, these values must be set at the project level')\n_p('TARGET     := $(TARGETDIR)/%s', _MAKE.esc(prj.buildtarget.name))\n_p('FLAGS      += /t:%s %s', csc.getkind(prj):lower(), table.implode(_MAKE.esc(prj.libdirs), \"/lib:\", \"\", \" \"))\n_p('REFERENCES += %s', table.implode(_MAKE.esc(premake.getlinks(prj, \"system\", \"basename\")), \"/r:\", \".dll\", \" \"))\n_p('')\n\n-- list source files\n_p('SOURCES := \\\\')\nfor _, fname in ipairs(sources) do\n_p('\\t%s \\\\', _MAKE.esc(path.translate(fname)))\nend\n_p('')\n\n_p('EMBEDFILES := \\\\')\nfor _, fname in ipairs(embedded) do\n_p('\\t%s \\\\', _MAKE.esc(getresourcefilename(prj, fname)))\nend\n_p('')\n\n_p('COPYFILES += \\\\')\nfor target, source in pairs(cfgpairs[anycfg]) do\n_p('\\t%s \\\\', _MAKE.esc(target))\nend\nfor target, source in pairs(copypairs) do\n_p('\\t%s \\\\', _MAKE.esc(target))\nend\n_p('')\n\n-- set up support commands like mkdir, rmdir, etc. based on the shell\n_p('SHELLTYPE := msdos')\n_p('ifeq (,$(ComSpec)$(COMSPEC))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (/bin,$(findstring /bin,$(SHELL)))')\n_p('  SHELLTYPE := posix')\n_p('endif')\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('   define MKDIR_RULE')\n_p('\\t@echo Creating $@')\n_p('\\t$(SILENT) mkdir -p $@')\n_p('   endef')\n_p('  define COPY_RULE')\n_p('\\t@echo Copying $(notdir $@)')\n_p('\\t$(SILENT) cp -fR $^ $@')\n_p('  endef')\n_p('else')\n_p('   define MKDIR_RULE')\n_p('\\t@echo Creating $@')\n_p('\\t$(SILENT) mkdir $(subst /,\\\\\\\\,$@)')\n_p('   endef')\n_p('  define COPY_RULE')\n_p('\\t@echo Copying $(notdir $@)')\n_p('\\t$(SILENT) copy /Y $(subst /,\\\\\\\\,$^) $(subst /,\\\\\\\\,$@)')\n_p('  endef')\n_p('endif')\n\n-- main build rule(s)\n_p('.PHONY: clean prebuild prelink')\n_p('')\n\n_p('all: $(TARGETDIR) $(OBJDIR) prebuild $(EMBEDFILES) $(COPYFILES) prelink $(TARGET)')\n_p('')\n\n_p('$(TARGET): $(SOURCES) $(EMBEDFILES) $(DEPENDS)')\n_p('\\t$(SILENT) $(CSC) /nologo /out:$@ $(FLAGS) $(REFERENCES) $(SOURCES) $(patsubst %%,/resource:%%,$(EMBEDFILES))')\n_p('\\t$(POSTBUILDCMDS)')\n_p('')\n\n-- create destination directories\n_p('$(TARGETDIR):')\n_p('\\t$(MKDIR_RULE)')\n_p('')\n\n_p('$(OBJDIR):')\n_p('\\t$(MKDIR_RULE)')\n_p('')\n\n-- clean target\n_p('clean:')\n_p('\\t@echo Cleaning %s', prj.name)\n_p('ifeq (posix,$(SHELLTYPE))')\n_p('\\t$(SILENT) rm -f $(TARGETDIR)/%s.* $(COPYFILES)', prj.buildtarget.basename)\n_p('\\t$(SILENT) rm -rf $(OBJDIR)')\n_p('else')\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(TARGETDIR)/%s.*) del $(subst /,\\\\\\\\,$(TARGETDIR)/%s.*)', prj.buildtarget.basename, prj.buildtarget.basename)\nfor target, source in pairs(cfgpairs[anycfg]) do\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,%s) del $(subst /,\\\\\\\\,%s)', target, target)\nend\nfor target, source in pairs(copypairs) do\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,%s) del $(subst /,\\\\\\\\,%s)', target, target)\nend\n_p('\\t$(SILENT) if exist $(subst /,\\\\\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\\\\\,$(OBJDIR))')\n_p('endif')\n_p('')\n\n-- custom build step targets\n_p('prebuild:')\n_p('\\t$(PREBUILDCMDS)')\n_p('')\n\n_p('prelink:')\n_p('\\t$(PRELINKCMDS)')\n_p('')\n\n-- per-file rules\n_p('# Per-configuration copied file rules')\nfor cfg in premake.eachconfig(prj) do\n_p('ifneq (,$(findstring %s,$(config)))', _MAKE.esc(cfg.name:lower()))\nfor target, source in pairs(cfgpairs[cfg]) do\n_p('%s: %s', _MAKE.esc(target), _MAKE.esc(source))\n_p('\\t$(COPY_RULE)')\nend\n_p('endif')\nend\n_p('')\n\n_p('# Copied file rules')\nfor target, source in pairs(copypairs) do\n_p('%s: %s', _MAKE.esc(target), _MAKE.esc(source))\n_p('\\t$(COPY_RULE)')\n_p('')\nend\n\n_p('# Embedded file rules')\nfor _, fname in ipairs(embedded) do \nif path.getextension(fname) == \".resx\" then\n_p('%s: %s', _MAKE.esc(getresourcefilename(prj, fname)), _MAKE.esc(fname))\n_p('\\t$(SILENT) $(RESGEN) $^ $@')\nend\n_p('')\nend\n\nend\n",
	"--\n\nfunction premake.vs2002_solution(sln)\nio.eol = '\\r\\n'\n\n_p('Microsoft Visual Studio Solution File, Format Version 7.00')\n\n-- Write out the list of project entries\nfor prj in premake.eachproject(sln) do\nlocal projpath = path.translate(path.getrelative(sln.location, _VS.projectfile(prj)))\n_p('Project(\"{%s}\") = \"%s\", \"%s\", \"{%s}\"', _VS.tool(prj), prj.name, projpath, prj.uuid)\n_p('EndProject')\nend\n\n_p('Global')\n_p('\\tGlobalSection(SolutionConfiguration) = preSolution')\nfor i, cfgname in ipairs(sln.configurations) do\n_p('\\t\\tConfigName.%d = %s', i - 1, cfgname)\nend\n_p('\\tEndGlobalSection')\n\n_p('\\tGlobalSection(ProjectDependencies) = postSolution')\n_p('\\tEndGlobalSection')\n\n_p('\\tGlobalSection(ProjectConfiguration) = postSolution')\nfor prj in premake.eachproject(sln) do\nfor _, cfgname in ipairs(sln.configurations) do\n_p('\\t\\t{%s}.%s.ActiveCfg = %s|%s', prj.uuid, cfgname, cfgname, _VS.arch(prj))\n_p('\\t\\t{%s}.%s.Build.0 = %s|%s', prj.uuid, cfgname, cfgname, _VS.arch(prj))\nend\nend\n_p('\\tEndGlobalSection')\n_p('\\tGlobalSection(ExtensibilityGlobals) = postSolution')\n_p('\\tEndGlobalSection')\n_p('\\tGlobalSection(ExtensibilityAddIns) = postSolution')\n_p('\\tEndGlobalSection')\n\n_p('EndGlobal')\nend\n",
	"--\n\n--\n-- Figure out what elements a particular file need in its item block,\n-- based on its build action and any related files in the project.\n-- \nlocal function getelements(prj, action, fname)\n\nif action == \"Compile\" and fname:endswith(\".cs\") then\nreturn \"SubTypeCode\"\nend\n\nif action == \"EmbeddedResource\" and fname:endswith(\".resx\") then\n-- is there a matching *.cs file?\nlocal basename = fname:sub(1, -6)\nlocal testname = path.getname(basename .. \".cs\")\nif premake.findfile(prj, testname) then\nreturn \"Dependency\", testname\nend\nend\n\nreturn \"None\"\nend\n\n\n\nfunction premake.vs2002_csproj(prj)\nio.eol = \"\\r\\n\"\n_p('<VisualStudioProject>')\n\n_p('\\t<CSHARP')\n_p('\\t\\tProjectType = \"Local\"')\n_p('\\t\\tProductVersion = \"%s\"', iif(_ACTION == \"vs2002\", \"7.0.9254\", \"7.10.3077\"))\n_p('\\t\\tSchemaVersion = \"%s\"', iif(_ACTION == \"vs2002\", \"1.0\", \"2.0\"))\n_p('\\t\\tProjectGuid = \"{%s}\"', prj.uuid)\n_p('\\t>')\n\n_p('\\t\\t<Build>')\n\n-- Write out project-wide settings\n_p('\\t\\t\\t<Settings')\n_p('\\t\\t\\t\\tApplicationIcon = \"\"')\n_p('\\t\\t\\t\\tAssemblyKeyContainerName = \"\"')\n_p('\\t\\t\\t\\tAssemblyName = \"%s\"', prj.buildtarget.basename)\n_p('\\t\\t\\t\\tAssemblyOriginatorKeyFile = \"\"')\n_p('\\t\\t\\t\\tDefaultClientScript = \"JScript\"')\n_p('\\t\\t\\t\\tDefaultHTMLPageLayout = \"Grid\"')\n_p('\\t\\t\\t\\tDefaultTargetSchema = \"IE50\"')\n_p('\\t\\t\\t\\tDelaySign = \"false\"')\nif _ACTION == \"vs2002\" then\n_p('\\t\\t\\t\\tNoStandardLibraries = \"false\"')\nend\n_p('\\t\\t\\t\\tOutputType = \"%s\"', premake.csc.getkind(prj))\nif _ACTION == \"vs2003\" then\n_p('\\t\\t\\t\\tPreBuildEvent = \"\"')\n_p('\\t\\t\\t\\tPostBuildEvent = \"\"')\nend\n_p('\\t\\t\\t\\tRootNamespace = \"%s\"', prj.buildtarget.basename)\nif _ACTION == \"vs2003\" then\n_p('\\t\\t\\t\\tRunPostBuildEvent = \"OnBuildSuccess\"')\nend\n_p('\\t\\t\\t\\tStartupObject = \"\"')\n_p('\\t\\t\\t>')\n\n-- Write out configuration blocks\nfor cfg in premake.eachconfig(prj) do\n_p('\\t\\t\\t\\t<Config')\n_p('\\t\\t\\t\\t\\tName = \"%s\"', premake.esc(cfg.name))\n_p('\\t\\t\\t\\t\\tAllowUnsafeBlocks = \"%s\"', iif(cfg.flags.Unsafe, \"true\", \"false\"))\n_p('\\t\\t\\t\\t\\tBaseAddress = \"285212672\"')\n_p('\\t\\t\\t\\t\\tCheckForOverflowUnderflow = \"false\"')\n_p('\\t\\t\\t\\t\\tConfigurationOverrideFile = \"\"')\n_p('\\t\\t\\t\\t\\tDefineConstants = \"%s\"', premake.esc(table.concat(cfg.defines, \";\")))\n_p('\\t\\t\\t\\t\\tDocumentationFile = \"\"')\n_p('\\t\\t\\t\\t\\tDebugSymbols = \"%s\"', iif(cfg.flags.Symbols, \"true\", \"false\"))\n_p('\\t\\t\\t\\t\\tFileAlignment = \"4096\"')\n_p('\\t\\t\\t\\t\\tIncrementalBuild = \"false\"')\nif _ACTION == \"vs2003\" then\n_p('\\t\\t\\t\\t\\tNoStdLib = \"false\"')\n_p('\\t\\t\\t\\t\\tNoWarn = \"\"')\nend\n_p('\\t\\t\\t\\t\\tOptimize = \"%s\"', iif(cfg.flags.Optimize or cfg.flags.OptimizeSize or cfg.flags.OptimizeSpeed, \"true\", \"false\"))\n_p('\\t\\t\\t\\t\\tOutputPath = \"%s\"', premake.esc(cfg.buildtarget.directory))\n_p('\\t\\t\\t\\t\\tRegisterForComInterop = \"false\"')\n_p('\\t\\t\\t\\t\\tRemoveIntegerChecks = \"false\"')\n_p('\\t\\t\\t\\t\\tTreatWarningsAsErrors = \"%s\"', iif(cfg.flags.FatalWarnings, \"true\", \"false\"))\n_p('\\t\\t\\t\\t\\tWarningLevel = \"4\"')\n_p('\\t\\t\\t\\t/>')\nend\n_p('\\t\\t\\t</Settings>')\n\n-- List assembly references\n_p('\\t\\t\\t<References>')\nfor _, ref in ipairs(premake.getlinks(prj, \"siblings\", \"object\")) do\n_p('\\t\\t\\t\\t<Reference')\n_p('\\t\\t\\t\\t\\tName = \"%s\"', ref.buildtarget.basename)\n_p('\\t\\t\\t\\t\\tProject = \"{%s}\"', ref.uuid)\n_p('\\t\\t\\t\\t\\tPackage = \"{%s}\"', _VS.tool(ref))\n_p('\\t\\t\\t\\t/>')\nend\nfor _, linkname in ipairs(premake.getlinks(prj, \"system\", \"fullpath\")) do\n_p('\\t\\t\\t\\t<Reference')\n_p('\\t\\t\\t\\t\\tName = \"%s\"', path.getbasename(linkname))\n_p('\\t\\t\\t\\t\\tAssemblyName = \"%s\"', path.getname(linkname))\nif path.getdirectory(linkname) ~= \".\" then\n_p('\\t\\t\\t\\t\\tHintPath = \"%s\"', path.translate(linkname, \"\\\\\"))\nend\n_p('\\t\\t\\t\\t/>')\nend\n_p('\\t\\t\\t</References>')\n\n_p('\\t\\t</Build>')\n\n-- List source files\n_p('\\t\\t<Files>')\n_p('\\t\\t\\t<Include>')\nfor fcfg in premake.eachfile(prj) do\nlocal action = premake.csc.getbuildaction(fcfg)\nlocal fname  = path.translate(premake.esc(fcfg.name), \"\\\\\")\nlocal elements, dependency = getelements(prj, action, fcfg.name)\n\n_p('\\t\\t\\t\\t<File')\n_p('\\t\\t\\t\\t\\tRelPath = \"%s\"', premake.esc(fname))\n_p('\\t\\t\\t\\t\\tBuildAction = \"%s\"', action)\nif dependency then\n_p('\\t\\t\\t\\t\\tDependentUpon = \"%s\"', premake.esc(path.translate(dependency, \"\\\\\")))\nend\nif elements == \"SubTypeCode\" then\n_p('\\t\\t\\t\\t\\tSubType = \"Code\"')\nend\n_p('\\t\\t\\t\\t/>')\nend\n_p('\\t\\t\\t</Include>')\n_p('\\t\\t</Files>')\n\n_p('\\t</CSHARP>')\n_p('</VisualStudioProject>')\n\nend\n",
	"--\n\nfunction premake.vs2002_csproj_user(prj)\nio.eol = \"\\r\\n\"\n\n_p('<VisualStudioProject>')\n_p('\\t<CSHARP>')\n_p('\\t\\t<Build>')\n\n-- Visual Studio wants absolute paths\nlocal refpaths = table.translate(prj.libdirs, function(v) return path.getabsolute(prj.location .. \"/\" .. v) end)\n_p('\\t\\t\\t<Settings ReferencePath = \"%s\">', path.translate(table.concat(refpaths, \";\"), \"\\\\\"))\n\nfor cfg in premake.eachconfig(prj) do\n_p('\\t\\t\\t\\t<Config')\n_p('\\t\\t\\t\\t\\tName = \"%s\"', premake.esc(cfg.name))\n_p('\\t\\t\\t\\t\\tEnableASPDebugging = \"false\"')\n_p('\\t\\t\\t\\t\\tEnableASPXDebugging = \"false\"')\n_p('\\t\\t\\t\\t\\tEnableUnmanagedDebugging = \"false\"')\n_p('\\t\\t\\t\\t\\tEnableSQLServerDebugging = \"false\"')\n_p('\\t\\t\\t\\t\\tRemoteDebugEnabled = \"false\"')\n_p('\\t\\t\\t\\t\\tRemoteDebugMachine = \"\"')\n_p('\\t\\t\\t\\t\\tStartAction = \"Project\"')\n_p('\\t\\t\\t\\t\\tStartArguments = \"\"')\n_p('\\t\\t\\t\\t\\tStartPage = \"\"')\n_p('\\t\\t\\t\\t\\tStartProgram = \"\"')\n_p('\\t\\t\\t\\t\\tStartURL = \"\"')\n_p('\\t\\t\\t\\t\\tStartWorkingDirectory = \"\"')\n_p('\\t\\t\\t\\t\\tStartWithIE = \"false\"')\n_p('\\t\\t\\t\\t/>')\nend\n\n_p('\\t\\t\\t</Settings>')\n_p('\\t\\t</Build>')\n_p('\\t\\t<OtherProjectSettings')\n_p('\\t\\t\\tCopyProjectDestinationFolder = \"\"')\n_p('\\t\\t\\tCopyProjectUncPath = \"\"')\n_p('\\t\\t\\tCopyProjectOption = \"0\"')\n_p('\\t\\t\\tProjectView = \"ProjectFiles\"')\n_p('\\t\\t\\tProjectTrust = \"0\"')\n_p('\\t\\t/>')\n\n_p('\\t</CSHARP>')\n_p('</VisualStudioProject>')\n\nend\n",
	"--\n\n\n\nlocal function buildstepsblock(name, steps)\n_p('\\t\\t\\t<Tool')\n_p('\\t\\t\\t\\tName=\"%s\"', name)\nif #steps > 0 then\n_p('\\t\\t\\t\\tCommandLine=\"%s\"', premake.esc(table.implode(steps, \"\", \"\", \"\\r\\n\")))\nend\n_p('\\t\\t\\t/>')\nend\n\n\n\nlocal function getsections(version, platform)\nif version == \"vs2002\" then\nreturn {\n\"VCCLCompilerTool\",\n\"VCCustomBuildTool\",\n\"VCLinkerTool\",\n\"VCMIDLTool\",\n\"VCPostBuildEventTool\",\n\"VCPreBuildEventTool\",\n\"VCPreLinkEventTool\",\n\"VCResourceCompilerTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCWebDeploymentTool\"\n}\nend\nif version == \"vs2003\" then\nreturn {\n\"VCCLCompilerTool\",\n\"VCCustomBuildTool\",\n\"VCLinkerTool\",\n\"VCMIDLTool\",\n\"VCPostBuildEventTool\",\n\"VCPreBuildEventTool\",\n\"VCPreLinkEventTool\",\n\"VCResourceCompilerTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebDeploymentTool\",\n\"VCManagedWrapperGeneratorTool\",\n\"VCAuxiliaryManagedWrapperGeneratorTool\"\n}\nend\nif platform == \"xbox360\" then\nreturn {\n\"VCPreBuildEventTool\",\n\"VCCustomBuildTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCMIDLTool\",\n\"VCCLX360CompilerTool\",\n\"VCManagedResourceCompilerTool\",\n\"VCResourceCompilerTool\",\n\"VCPreLinkEventTool\",\n\"VCX360LinkerTool\",\n\"VCALinkTool\",\n\"VCX360ImageTool\",\n\"VCBscMakeTool\",\n\"VCX360DeploymentTool\",\n\"VCPostBuildEventTool\",\n\"DebuggerTool\",\n}\nelse\nreturn {\n\"VCPreBuildEventTool\",\n\"VCCustomBuildTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCMIDLTool\",\n\"VCCLCompilerTool\",\n\"VCManagedResourceCompilerTool\",\n\"VCResourceCompilerTool\",\n\"VCPreLinkEventTool\",\n\"VCLinkerTool\",\n\"VCALinkTool\",\n\"VCManifestTool\",\n\"VCXDCMakeTool\",\n\"VCBscMakeTool\",\n\"VCFxCopTool\",\n\"VCAppVerifierTool\",\n\"VCWebDeploymentTool\",\n\"VCPostBuildEventTool\"\n}\nend\nend\n\n\n\nfunction premake.vs200x_vcproj(prj)\nio.eol = \"\\r\\n\"\n_p('<?xml version=\"1.0\" encoding=\"Windows-1252\"?>')\n\n-- Write opening project block\n_p('<VisualStudioProject')\n_p('\\tProjectType=\"Visual C++\"')\nif _ACTION == \"vs2002\" then\n_p('\\tVersion=\"7.00\"')\nelseif _ACTION == \"vs2003\" then\n_p('\\tVersion=\"7.10\"')\nelseif _ACTION == \"vs2005\" then\n_p('\\tVersion=\"8.00\"')\nelseif _ACTION == \"vs2008\" then\n_p('\\tVersion=\"9.00\"')\nend\n_p('\\tName=\"%s\"', premake.esc(prj.name))\n_p('\\tProjectGUID=\"{%s}\"', prj.uuid)\nif _ACTION > \"vs2003\" then\n_p('\\tRootNamespace=\"%s\"', prj.name)\nend\n_p('\\tKeyword=\"%s\"', iif(prj.flags.Managed, \"ManagedCProj\", \"Win32Proj\"))\n_p('\\t>')\n\n-- list the target platforms\nlocal platforms = premake.vstudio_filterplatforms(prj.solution)\n_p('\\t<Platforms>')\nfor _, platform in ipairs(platforms) do\n_p('\\t\\t<Platform')\n_p('\\t\\t\\tName=\"%s\"', premake.vstudio_platforms[platform])\n_p('\\t\\t/>')\nend\n_p('\\t</Platforms>')\n\nif _ACTION > \"vs2003\" then\n_p('\\t<ToolFiles>')\n_p('\\t</ToolFiles>')\nend\n\n_p('\\t<Configurations>')\nfor _, platform in ipairs(platforms) do\nfor cfg in premake.eachconfig(prj, platform) do\n\n-- Start a configuration\n_p('\\t\\t<Configuration')\n_p('\\t\\t\\tName=\"%s|%s\"', premake.esc(cfg.name), premake.vstudio_platforms[platform])\n_p('\\t\\t\\tOutputDirectory=\"%s\"', premake.esc(cfg.buildtarget.directory))\n_p('\\t\\t\\tIntermediateDirectory=\"%s\"', premake.esc(cfg.objectsdir))\n_p('\\t\\t\\tConfigurationType=\"%s\"', _VS.cfgtype(cfg))\n_p('\\t\\t\\tCharacterSet=\"%s\"', iif(cfg.flags.Unicode, 1, 2))\nif cfg.flags.Managed then\n_p('\\t\\t\\tManagedExtensions=\"true\"')\nend\n_p('\\t\\t\\t>')\n\nfor _, block in ipairs(getsections(_ACTION, platform)) do\n\n-- Compiler block --\nif block == \"VCCLCompilerTool\" or block == \"VCCLX360CompilerTool\" then\n_p('\\t\\t\\t<Tool')\n_p('\\t\\t\\t\\tName=\"%s\"', block)\nif #cfg.buildoptions > 0 then\n_p('\\t\\t\\t\\tAdditionalOptions=\"%s\"', table.concat(premake.esc(cfg.buildoptions), \" \"))\nend\n_p('\\t\\t\\t\\tOptimization=\"%s\"', _VS.optimization(cfg))\nif cfg.flags.NoFramePointer then\n_p('\\t\\t\\t\\tOmitFramePointers=\"%s\"', _VS.bool(true))\nend\nif #cfg.includedirs > 0 then\n_p('\\t\\t\\t\\tAdditionalIncludeDirectories=\"%s\"', table.concat(premake.esc(cfg.includedirs), \";\"))\nend\nif #cfg.defines > 0 then\n_p('\\t\\t\\t\\tPreprocessorDefinitions=\"%s\"', table.concat(premake.esc(cfg.defines), \";\"))\nend\nif cfg.flags.Symbols and not cfg.flags.Managed then\n_p('\\t\\t\\t\\tMinimalRebuild=\"%s\"', _VS.bool(true))\nend\nif cfg.flags.NoExceptions then\n_p('\\t\\t\\t\\tExceptionHandling=\"%s\"', iif(_ACTION < \"vs2005\", \"FALSE\", 0))\nelseif cfg.flags.SEH and _ACTION > \"vs2003\" then\n_p('\\t\\t\\t\\tExceptionHandling=\"2\"')\nend\nif _VS.optimization(cfg) == 0 and not cfg.flags.Managed then\n_p('\\t\\t\\t\\tBasicRuntimeChecks=\"3\"')\nend\nif _VS.optimization(cfg) ~= 0 then\n_p('\\t\\t\\t\\tStringPooling=\"%s\"', _VS.bool(true))\nend\n_p('\\t\\t\\t\\tRuntimeLibrary=\"%s\"', _VS.runtime(cfg))\n_p('\\t\\t\\t\\tEnableFunctionLevelLinking=\"%s\"', _VS.bool(true))\nif _ACTION < \"vs2005\" and not cfg.flags.NoRTTI then\n_p('\\t\\t\\t\\tRuntimeTypeInfo=\"%s\"', _VS.bool(true))\nelseif _ACTION > \"vs2003\" and cfg.flags.NoRTTI then\n_p('\\t\\t\\t\\tRuntimeTypeInfo=\"%s\"', _VS.bool(false))\nend\nif cfg.flags.NativeWChar then\n_p('\\t\\t\\t\\tTreatWChar_tAsBuiltInType=\"%s\"', _VS.bool(true))\nelseif cfg.flags.NoNativeWChar then\n_p('\\t\\t\\t\\tTreatWChar_tAsBuiltInType=\"%s\"', _VS.bool(false))\nend\nif not cfg.flags.NoPCH and cfg.pchheader then\n_p('\\t\\t\\t\\tUsePrecompiledHeader=\"%s\"', iif(_ACTION < \"vs2005\", 3, 2))\n_p('\\t\\t\\t\\tPrecompiledHeaderThrough=\"%s\"', cfg.pchheader)\nelse\n_p('\\t\\t\\t\\tUsePrecompiledHeader=\"%s\"', iif(_ACTION > \"vs2003\" or cfg.flags.NoPCH, 0, 2))\nend\n_p('\\t\\t\\t\\tWarningLevel=\"%s\"', iif(cfg.flags.ExtraWarnings, 4, 3))\nif cfg.flags.FatalWarnings then\n_p('\\t\\t\\t\\tWarnAsError=\"%s\"', _VS.bool(true))\nend\nif _ACTION < \"vs2008\" and not cfg.flags.Managed then\n_p('\\t\\t\\t\\tDetect64BitPortabilityProblems=\"%s\"', _VS.bool(not cfg.flags.No64BitChecks))\nend\n_p('\\t\\t\\t\\tProgramDataBaseFileName=\"$(OutDir)\\\\$(ProjectName).pdb\"')\n_p('\\t\\t\\t\\tDebugInformationFormat=\"%s\"', _VS.symbols(cfg))\n_p('\\t\\t\\t/>')\n-- End compiler block --\n\n-- Linker block --\nelseif block == \"VCLinkerTool\" or block == \"VCX360LinkerTool\" then\n_p('\\t\\t\\t<Tool')\nif cfg.kind ~= \"StaticLib\" then\n_p('\\t\\t\\t\\tName=\"%s\"', block)\nif cfg.flags.NoImportLib then\n_p('\\t\\t\\t\\tIgnoreImportLibrary=\"%s\"', _VS.bool(true))\nend\nif #cfg.linkoptions > 0 then\n_p('\\t\\t\\t\\tAdditionalOptions=\"%s\"', table.concat(premake.esc(cfg.linkoptions), \" \"))\nend\nif #cfg.links > 0 then\n_p('\\t\\t\\t\\tAdditionalDependencies=\"%s\"', table.concat(premake.getlinks(cfg, \"all\", \"fullpath\"), \" \"))\nend\n_p('\\t\\t\\t\\tOutputFile=\"$(OutDir)\\\\%s\"', cfg.buildtarget.name)\n_p('\\t\\t\\t\\tLinkIncremental=\"%s\"', iif(_VS.optimization(cfg) == 0, 2, 1))\n_p('\\t\\t\\t\\tAdditionalLibraryDirectories=\"%s\"', table.concat(premake.esc(path.translate(cfg.libdirs)) , \";\"))\nlocal deffile = premake.findfile(cfg, \".def\")\nif deffile then\n_p('\\t\\t\\t\\tModuleDefinitionFile=\"%s\"', deffile)\nend\nif cfg.flags.NoManifest then\n_p('\\t\\t\\t\\tGenerateManifest=\"%s\"', _VS.bool(false))\nend\n_p('\\t\\t\\t\\tGenerateDebugInformation=\"%s\"', _VS.bool(_VS.symbols(cfg) ~= 0))\nif _VS.symbols(cfg) ~= 0 then\n_p('\\t\\t\\t\\tProgramDatabaseFile=\"$(OutDir)\\\\$(ProjectName).pdb\"')\nend\n_p('\\t\\t\\t\\tSubSystem=\"%s\"', iif(cfg.kind == \"ConsoleApp\", 1, 2))\nif _VS.optimization(cfg) ~= 0 then\n_p('\\t\\t\\t\\tOptimizeReferences=\"2\"')\n_p('\\t\\t\\t\\tEnableCOMDATFolding=\"2\"')\nend\nif (cfg.kind == \"ConsoleApp\" or cfg.kind == \"WindowedApp\") and not cfg.flags.WinMain then\n_p('\\t\\t\\t\\tEntryPointSymbol=\"mainCRTStartup\"')\nend\nif cfg.kind == \"SharedLib\" then\nlocal implibname = path.translate(premake.gettarget(cfg, \"link\", \"windows\").fullpath, \"\\\\\")\n_p('\\t\\t\\t\\tImportLibrary=\"%s\"', iif(cfg.flags.NoImportLib, cfg.objectsdir .. \"\\\\\" .. path.getname(implibname), implibname))\nend\n_p('\\t\\t\\t\\tTargetMachine=\"1\"')\nelse\n_p('\\t\\t\\t\\tName=\"VCLibrarianTool\"')\nif #cfg.links > 0 then\n_p('\\t\\t\\t\\tAdditionalDependencies=\"%s\"', table.concat(premake.getlinks(cfg, \"all\", \"fullpath\"), \" \"))\nend\n_p('\\t\\t\\t\\tOutputFile=\"$(OutDir)\\\\%s\"', cfg.buildtarget.name)\n_p('\\t\\t\\t\\tAdditionalLibraryDirectories=\"%s\"', table.concat(premake.esc(path.translate(cfg.libdirs)) , \";\"))\nend\n_p('\\t\\t\\t/>')\n-- End linker block --\n\n-- Resource compiler --\nelseif block == \"VCResourceCompilerTool\" then\n_p('\\t\\t\\t<Tool')\n_p('\\t\\t\\t\\tName=\"VCResourceCompilerTool\"')\nif #cfg.resoptions > 0 then\n_p('\\t\\t\\t\\tAdditionalOptions=\"%s\"', table.concat(premake.esc(cfg.resoptions), \" \"))\nend\nif #cfg.defines > 0 or #cfg.resdefines > 0 then\n_p('\\t\\t\\t\\tPreprocessorDefinitions=\"%s\"', table.concat(premake.esc(table.join(cfg.defines, cfg.resdefines)), \";\"))\nend\nif #cfg.includedirs > 0 or #cfg.resincludedirs > 0 then\n_p('\\t\\t\\t\\tAdditionalIncludeDirectories=\"%s\"', table.concat(premake.esc(table.join(cfg.includedirs, cfg.resincludedirs)), \";\"))\nend\n_p('\\t\\t\\t/>')\n-- End resource compiler --\n\n-- Build event blocks --\nelseif block == \"VCPreBuildEventTool\" then\nbuildstepsblock(\"VCPreBuildEventTool\", cfg.prebuildcommands)\nelseif block == \"VCPreLinkEventTool\" then\nbuildstepsblock(\"VCPreLinkEventTool\", cfg.prelinkcommands)\nelseif block == \"VCPostBuildEventTool\" then\nbuildstepsblock(\"VCPostBuildEventTool\", cfg.postbuildcommands)\n-- End build event blocks --\n\n-- Xbox 360 custom sections --\nelseif block == \"VCX360DeploymentTool\" then\n_p('\\t\\t\\t<Tool')\n_p('\\t\\t\\t\\tName=\"VCX360DeploymentTool\"')\n_p('\\t\\t\\t\\tDeploymentType=\"0\"')\n_p('\\t\\t\\t/>')\n\nelseif block == \"DebuggerTool\" then\n_p('\\t\\t\\t<DebuggerTool')\n_p('\\t\\t\\t/>')\n-- End Xbox 360 custom sections --\n\nelse\n_p('\\t\\t\\t<Tool')\n_p('\\t\\t\\t\\tName=\"%s\"', block)\n_p('\\t\\t\\t/>')\nend\n\nend\n_p('\\t\\t</Configuration>')\nend\nend\n_p('\\t</Configurations>')\n\n_p('\\t<References>')\n_p('\\t</References>')\n\n_p('\\t<Files>')\npremake.walksources(prj, prj.files, _VS.files)\n_p('\\t</Files>')\n\n_p('\\t<Globals>')\n_p('\\t</Globals>')\n_p('</VisualStudioProject>')\nend\n\n\n",
	"--\n\nfunction premake.vs2003_solution(sln)\nio.eol = '\\r\\n'\n\n_p('Microsoft Visual Studio Solution File, Format Version 8.00')\n\n-- Write out the list of project entries\nfor prj in premake.eachproject(sln) do\nlocal projpath = path.translate(path.getrelative(sln.location, _VS.projectfile(prj)))\n_p('Project(\"{%s}\") = \"%s\", \"%s\", \"{%s}\"', _VS.tool(prj), prj.name, projpath, prj.uuid)\n\nlocal deps = premake.getdependencies(prj)\nif #deps > 0 then\n_p('\\tProjectSection(ProjectDependencies) = postProject')\nfor _, dep in ipairs(deps) do\n_p('\\t\\t{%s} = {%s}', dep.uuid, dep.uuid)\nend\n_p('\\tEndProjectSection')\nend\n\n_p('EndProject')\nend\n\n_p('Global')\n_p('\\tGlobalSection(SolutionConfiguration) = preSolution')\nfor _, cfgname in ipairs(sln.configurations) do\n_p('\\t\\t%s = %s', cfgname, cfgname)\nend\n_p('\\tEndGlobalSection')\n\n_p('\\tGlobalSection(ProjectDependencies) = postSolution')\n_p('\\tEndGlobalSection')\n\n_p('\\tGlobalSection(ProjectConfiguration) = postSolution')\nfor prj in premake.eachproject(sln) do\nfor _, cfgname in ipairs(sln.configurations) do\n_p('\\t\\t{%s}.%s.ActiveCfg = %s|%s', prj.uuid, cfgname, cfgname, _VS.arch(prj))\n_p('\\t\\t{%s}.%s.Build.0 = %s|%s', prj.uuid, cfgname, cfgname, _VS.arch(prj))\nend\nend\n_p('\\tEndGlobalSection')\n\n_p('\\tGlobalSection(ExtensibilityGlobals) = postSolution')\n_p('\\tEndGlobalSection')\n_p('\\tGlobalSection(ExtensibilityAddIns) = postSolution')\n_p('\\tEndGlobalSection')\n\n_p('EndGlobal')\nend\n",
	"--\n\n\nfunction premake.vs2005_solution(sln)\nio.eol = '\\r\\n'\n\n-- Mark the file as Unicode\n_p('\\239\\187\\191')\n\n-- Write the solution file version header\nif _ACTION == \"vs2005\" then\n_p('Microsoft Visual Studio Solution File, Format Version 9.00')\n_p('# Visual Studio 2005')\nelse\n_p('Microsoft Visual Studio Solution File, Format Version 10.00')\n_p('# Visual Studio 2008')\nend\n\n-- Write out the list of project entries\nfor prj in premake.eachproject(sln) do\n-- Build a relative path from the solution file to the project file\nlocal projpath = path.translate(path.getrelative(sln.location, _VS.projectfile(prj)), \"\\\\\")\n\n_p('Project(\"{%s}\") = \"%s\", \"%s\", \"{%s}\"', _VS.tool(prj), prj.name, projpath, prj.uuid)\nlocal deps = premake.getdependencies(prj)\nif #deps > 0 then\n_p('\\tProjectSection(ProjectDependencies) = postProject')\nfor _, dep in ipairs(deps) do\n_p('\\t\\t{%s} = {%s}', dep.uuid, dep.uuid)\nend\n_p('\\tEndProjectSection')\nend\n_p('EndProject')\nend\n\nlocal platforms = premake.vs2005_solution_platforms(sln)\n\n_p('Global')\npremake.vs2005_solution_configurations(sln, platforms)\npremake.vs2005_solution_project_configurations(sln, platforms)\npremake.vs2005_solution_properties(sln)\n_p('EndGlobal')\nend\n\n\n\n\nfunction premake.vs2005_solution_configurations(sln, platforms)\n_p('\\tGlobalSection(SolutionConfigurationPlatforms) = preSolution')\nfor _, cfgname in ipairs(sln.configurations) do\nfor _, platform in ipairs(platforms) do\nlocal platname = premake.vstudio_platforms[platform]\n_p('\\t\\t%s|%s = %s|%s', cfgname, platname, cfgname, platname)\nend\nend\n_p('\\tEndGlobalSection')\nend\n\n\n\n\nfunction premake.vs2005_solution_project_configurations(sln, platforms)\n_p('\\tGlobalSection(ProjectConfigurationPlatforms) = postSolution')\nfor prj in premake.eachproject(sln) do\nfor _, cfgname in ipairs(sln.configurations) do\nfor i, platform in ipairs(platforms) do\nlocal platname = premake.vstudio_platforms[platform]\n\n-- .NET projects always use \"Any CPU\" platform (for now, at least)\n-- C++ projects use the current platform, or the first C++ platform \n-- if the current one is for .NET\nlocal mappedname\nif premake.isdotnetproject(prj) then\nmappedname = \"Any CPU\"\nelse\nmappedname = premake.vstudio_platforms[platforms[math.max(i, platforms._offset)]]\nend\n\n_p('\\t\\t{%s}.%s|%s.ActiveCfg = %s|%s', prj.uuid, cfgname, platname, cfgname, mappedname)\nif (platname == mappedname or platname == \"Mixed Platforms\") then\n_p('\\t\\t{%s}.%s|%s.Build.0 = %s|%s',  prj.uuid, cfgname, platname, cfgname, mappedname)\nend\nend\nend\nend\n\n_p('\\tEndGlobalSection')\nend\n\n\n\n\nfunction premake.vs2005_solution_properties(sln)\n_p('\\tGlobalSection(SolutionProperties) = preSolution')\n_p('\\t\\tHideSolutionNode = FALSE')\n_p('\\tEndGlobalSection')\nend\n\n\n\n\nfunction premake.vs2005_solution_platforms(sln)\nlocal platforms = premake.filterplatforms(sln, premake.vstudio_platforms, \"x32\")\nplatforms._offset = 1\n\nlocal hascpp    = premake.hascppproject(sln)\nlocal hasdotnet = premake.hasdotnetproject(sln)\nif hasdotnet then\ntable.insert(platforms, 1, \"any\")\nplatforms._offset = 2\nend\nif hasdotnet and hascpp then\ntable.insert(platforms, 2, \"mixed\")\nplatforms._offset = 3\nend\n\nreturn platforms\nend\n",
	"--\n\n--\n-- Figure out what elements a particular source code file need in its item\n-- block, based on its build action and any related files in the project.\n-- \n\nfunction getelements(prj, action, fname)\n\nif action == \"Compile\" and fname:endswith(\".cs\") then\nif fname:endswith(\".Designer.cs\") then\n-- is there a matching *.cs file?\nlocal basename = fname:sub(1, -13)\nlocal testname = basename .. \".cs\"\nif premake.findfile(prj, testname) then\nreturn \"Dependency\", testname\nend\n-- is there a matching *.resx file?\ntestname = basename .. \".resx\"\nif premake.findfile(prj, testname) then\nreturn \"AutoGen\", testname\nend\nelse\n-- is there a *.Designer.cs file?\nlocal basename = fname:sub(1, -4)\nlocal testname = basename .. \".Designer.cs\"\nif premake.findfile(prj, testname) then\nreturn \"SubTypeForm\"\nend\nend\nend\n\nif action == \"EmbeddedResource\" and fname:endswith(\".resx\") then\n-- is there a matching *.cs file?\nlocal basename = fname:sub(1, -6)\nlocal testname = path.getname(basename .. \".cs\")\nif premake.findfile(prj, testname) then\nif premake.findfile(prj, basename .. \".Designer.cs\") then\nreturn \"DesignerType\", testname\nelse\nreturn \"Dependency\", testname\nend\nelse\n-- is there a matching *.Designer.cs?\ntestname = path.getname(basename .. \".Designer.cs\")\nif premake.findfile(prj, testname) then\nreturn \"AutoGenerated\"\nend\nend\nend\n\nif action == \"Content\" then\nreturn \"CopyNewest\"\nend\n\nreturn \"None\"\nend\n\n\nfunction premake.vs2005_csproj(prj)\nio.eol = \"\\r\\n\"\n\nlocal vsversion, toolversion\nif _ACTION == \"vs2005\" then\nvsversion   = \"8.0.50727\"\ntoolversion = nil\nelseif _ACTION == \"vs2008\" then\nvsversion   = \"9.0.50727\"\ntoolversion = \"3.5\"\nend\n\nif toolversion then\n_p('<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" ToolsVersion=\"%s\">', toolversion)\nelse\n_p('<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">')\nend\n\n_p('  <PropertyGroup>')\n_p('    <Configuration Condition=\" \\'$(Configuration)\\' == \\'\\' \">%s</Configuration>', premake.esc(prj.solution.configurations[1]))\n_p('    <Platform Condition=\" \\'$(Platform)\\' == \\'\\' \">AnyCPU</Platform>')\n_p('    <ProductVersion>%s</ProductVersion>', vsversion)\n_p('    <SchemaVersion>2.0</SchemaVersion>')\n_p('    <ProjectGuid>{%s}</ProjectGuid>', prj.uuid)\n_p('    <OutputType>%s</OutputType>', premake.csc.getkind(prj))\n_p('    <AppDesignerFolder>Properties</AppDesignerFolder>')\n_p('    <RootNamespace>%s</RootNamespace>', prj.buildtarget.basename)\n_p('    <AssemblyName>%s</AssemblyName>', prj.buildtarget.basename)\n_p('  </PropertyGroup>')\n\nfor cfg in premake.eachconfig(prj) do\n_p('  <PropertyGroup Condition=\" \\'$(Configuration)|$(Platform)\\' == \\'%s|AnyCPU\\' \">', premake.esc(cfg.name))\nif cfg.flags.Symbols then\n_p('    <DebugSymbols>true</DebugSymbols>')\n_p('    <DebugType>full</DebugType>')\nelse\n_p('    <DebugType>pdbonly</DebugType>')\nend\n_p('    <Optimize>%s</Optimize>', iif(cfg.flags.Optimize or cfg.flags.OptimizeSize or cfg.flags.OptimizeSpeed, \"true\", \"false\"))\n_p('    <OutputPath>%s</OutputPath>', cfg.buildtarget.directory)\n_p('    <DefineConstants>%s</DefineConstants>', table.concat(premake.esc(cfg.defines), \";\"))\n_p('    <ErrorReport>prompt</ErrorReport>')\n_p('    <WarningLevel>4</WarningLevel>')\nif cfg.flags.Unsafe then\n_p('    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>')\nend\nif cfg.flags.FatalWarnings then\n_p('    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>')\nend\n_p('  </PropertyGroup>')\nend\n\n_p('  <ItemGroup>')\nfor _, prj in ipairs(premake.getlinks(prj, \"siblings\", \"object\")) do\n_p('    <ProjectReference Include=\"%s\">', path.translate(path.getrelative(prj.location, _VS.projectfile(prj)), \"\\\\\"))\n_p('      <Project>{%s}</Project>', prj.uuid)\n_p('      <Name>%s</Name>', premake.esc(prj.name))\n_p('    </ProjectReference>')\nend\nfor _, linkname in ipairs(premake.getlinks(prj, \"system\", \"basename\")) do\n_p('    <Reference Include=\"%s\" />', premake.esc(linkname))\nend\n_p('  </ItemGroup>')\n\n_p('  <ItemGroup>')\nfor fcfg in premake.eachfile(prj) do\nlocal action = premake.csc.getbuildaction(fcfg)\nlocal fname  = path.translate(premake.esc(fcfg.name), \"\\\\\")\nlocal elements, dependency = getelements(prj, action, fcfg.name)\nif elements == \"None\" then\n_p('    <%s Include=\"%s\" />', action, fname)\nelse\n_p('    <%s Include=\"%s\">', action, fname)\nif elements == \"AutoGen\" then\n_p('      <AutoGen>True</AutoGen>')\nelseif elements == \"AutoGenerated\" then\n_p('      <SubType>Designer</SubType>')\n_p('      <Generator>ResXFileCodeGenerator</Generator>')\n_p('      <LastGenOutput>%s.Designer.cs</LastGenOutput>', premake.esc(path.getbasename(fcfg.name)))\nelseif elements == \"SubTypeDesigner\" then\n_p('      <SubType>Designer</SubType>')\nelseif elements == \"SubTypeForm\" then\n_p('      <SubType>Form</SubType>')\nelseif elements == \"PreserveNewest\" then\n_p('      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>')\nend\nif dependency then\n_p('      <DependentUpon>%s</DependentUpon>', path.translate(premake.esc(dependency), \"\\\\\"))\nend\n_p('    </%s>', action)\nend\nend\n_p('  </ItemGroup>')\n\n_p('  <Import Project=\"$(MSBuildBinPath)\\\\Microsoft.CSharp.targets\" />')\n_p('  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.')\n_p('       Other similar extension points exist, see Microsoft.Common.targets.')\n_p('  <Target Name=\"BeforeBuild\">')\n_p('  </Target>')\n_p('  <Target Name=\"AfterBuild\">')\n_p('  </Target>')\n_p('  -->')\n_p('</Project>')\nend\n\n",
	"--\n\nfunction premake.vs2005_csproj_user(prj)\nio.eol = \"\\r\\n\"\n\n_p('<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">')\n_p('  <PropertyGroup>')\n\nlocal refpaths = table.translate(prj.libdirs, function(v) return path.getabsolute(prj.location .. \"/\" .. v) end)\n_p('    <ReferencePath>%s</ReferencePath>', path.translate(table.concat(refpaths, \";\"), \"\\\\\"))\n_p('  </PropertyGroup>')\n_p('</Project>')\n\nend\n",
	"--\n\n\nlocal scriptfile    = \"premake4.lua\"\nlocal shorthelp     = \"Type 'premake4 --help' for help\"\nlocal versionhelp   = \"premake4 (Premake Build Script Generator) %s\"\n\n\n\n\nlocal function doaction(name)\nlocal action = premake.actions[name]\n\n-- walk the session objects and generate files from the templates\nlocal function generatefiles(this, templates)\nif (not templates) then return end\nfor _,tmpl in ipairs(templates) do\nlocal output = true\nif (tmpl[3]) then\noutput = tmpl[3](this)\nend\nif (output) then\nlocal fname = path.getrelative(os.getcwd(), premake.getoutputname(this, tmpl[1]))\nprintf(\"Generating %s...\", fname)\nlocal f, err = io.open(fname, \"wb\")\nif (not f) then\nerror(err, 0)\nend\nio.output(f)\n\n-- call the template function to generate the output\ntmpl[2](this)\n\nio.output():close()\nend\nend\nend\n\nfor _,sln in ipairs(_SOLUTIONS) do\ngeneratefiles(sln, action.solutiontemplates)\nfor prj in premake.eachproject(sln) do\ngeneratefiles(prj, action.projecttemplates)\nend\nend\n\nif (action.execute) then\naction.execute()\nend\nend\n\n\n\n\nfunction _premake_main(scriptpath)\n\n-- if running off the disk (in debug mode), load everything \n-- listed in _manifest.lua; the list divisions make sure\n-- everything gets initialized in the proper order.\n\nif (scriptpath) then\nlocal scripts, templates, actions  = dofile(scriptpath .. \"/_manifest.lua\")\n\n-- core code first\nfor _,v in ipairs(scripts) do\ndofile(scriptpath .. \"/\" .. v)\nend\n\n-- then the templates\nfor _,v in ipairs(templates) do\nlocal name = path.getbasename(v)\n_TEMPLATES[name] = premake.loadtemplatefile(scriptpath .. \"/\" .. v)\nend\n\n-- finally the actions\nfor _,v in ipairs(actions) do\ndofile(scriptpath .. \"/\" .. v)\nend\nend\n\n\n-- If there is a project script available, run it to get the\n-- project information, available options and actions, etc.\n\nlocal fname = _OPTIONS[\"file\"] or scriptfile\nif (os.isfile(fname)) then\ndofile(fname)\nend\n\n\n-- Process special options\n\nif (_OPTIONS[\"version\"]) then\nprintf(versionhelp, _PREMAKE_VERSION)\nreturn 1\nend\n\nif (_OPTIONS[\"help\"]) then\npremake.showhelp()\nreturn 1\nend\n\n\n-- If no action was specified, show a short help message\n\nif (not _ACTION) then\nprint(shorthelp)\nreturn 1\nend\n\n\n-- If there wasn't a project script I've got to bail now\n\nif (not os.isfile(fname)) then\nerror(\"No Premake script (\"..scriptfile..\") found!\", 2)\nend\n\n\n-- Validate the command-line arguments. This has to happen after the\n-- script has run to allow for project-specific options\n\nif (not premake.actions[_ACTION]) then\nerror(\"Error: no such action '\".._ACTION..\"'\", 0)\nend\n\nok, err = premake.checkoptions()\nif (not ok) then error(\"Error: \" .. err, 0) end\n\n\n-- Sanity check the current project setup\n\nok, err = premake.checktools()\nif (not ok) then error(\"Error: \" .. err, 0) end\n\n-- work-in-progress: build the configurations\nprint(\"Building configurations...\")\npremake.buildconfigs()\n\nok, err = premake.checkprojects()\nif (not ok) then error(\"Error: \" .. err, 0) end\n\n\n-- Hand over control to the action\nprintf(\"Running action '%s'...\", _ACTION)\ndoaction(_ACTION)\n\nprint(\"Done.\")\nreturn 0\n\nend\n",
	"_TEMPLATES.codeblocks_workspace=premake.loadtemplatestring('codeblocks_workspace',[[<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n<CodeBlocks_workspace_file>\n	<Workspace title=\"<%= this.name %>\">\n	<% for prj in premake.eachproject(this) do %>\n		<Project filename=\"<%= path.join(path.getrelative(this.location, prj.location), prj.name) %>.cbp\"<%= iif(prj.project==this.projects[1], ' active=\"1\"', '') %>>\n		<% for _,dep in ipairs(premake.getdependencies(prj)) do %>\n			<Depends filename=\"<%= path.join(path.getrelative(this.location, dep.location), dep.name) %>.cbp\" />\n		<% end %>\n		</Project>\n	<% end %>\n	</Workspace>\n</CodeBlocks_workspace_file>\n]])",
	"_TEMPLATES.codeblocks_cbp=premake.loadtemplatestring('codeblocks_cbp',[[<% local cc = premake[_OPTIONS.cc] %>\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n<CodeBlocks_project_file>\n	<FileVersion major=\"1\" minor=\"6\" />\n	<Project>\n		<Option title=\"<%= premake.esc(this.name) %>\" />\n		<Option pch_mode=\"2\" />\n		<Option compiler=\"<%= _OPTIONS.cc %>\" />\n		<Build>\n		<% for cfg in premake.eachconfig(this) do %>\n			<Target title=\"<%= premake.esc(cfg.name) %>\">\n				<Option output=\"<%= premake.esc(cfg.buildtarget.fullpath) %>\" prefix_auto=\"0\" extension_auto=\"0\" />\n				<Option object_output=\"<%= premake.esc(cfg.objectsdir) %>\" />\n				<% if (cfg.kind == \"WindowedApp\") then %>\n				<Option type=\"0\" />\n				<% elseif (cfg.kind == \"ConsoleApp\") then %>\n				<Option type=\"1\" />\n				<% elseif (cfg.kind == \"StaticLib\") then %>\n				<Option type=\"2\" />\n				<% elseif (cfg.kind == \"SharedLib\") then %>\n				<Option type=\"3\" />\n				<% end %>\n				<Option compiler=\"<%= _OPTIONS.cc %>\" />\n				<% if (cfg.kind == \"SharedLib\") then %>\n				<Option createDefFile=\"0\" />\n				<Option createStaticLib=\"<%= iif(cfg.flags.NoImportLib, 0, 1) %>\" />\n				<% end %>\n				<Compiler>\n					<% for _,flag in ipairs(table.join(cc.getcflags(cfg), cc.getcxxflags(cfg), cc.getdefines(cfg.defines), cfg.buildoptions)) do %>\n					<Add option=\"<%= premake.esc(flag) %>\" />\n					<% end %>\n					<% if not cfg.flags.NoPCH and cfg.pchheader then %>\n					<Add option=\"-Winvalid-pch\" />\n					<Add option=\"-include &quot;<%= premake.esc(cfg.pchheader) %>&quot;\" />\n					<% end %>\n					<% for _,v in ipairs(cfg.includedirs) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</Compiler>\n				<Linker>\n					<% for _,flag in ipairs(table.join(cc.getldflags(cfg), cfg.linkoptions)) do %>\n					<Add option=\"<%= premake.esc(flag) %>\" />\n					<% end %>\n					<% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"directory\")) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n					<% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"basename\")) do %>\n					<Add library=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</Linker>\n				<% if premake.findfile(cfg, \".rc\") then %>\n				<ResourceCompiler>\n					<% for _,v in ipairs(cfg.includedirs) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n					<% for _,v in ipairs(cfg.resincludedirs) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</ResourceCompiler>\n				<% end %>\n				<% if #cfg.prebuildcommands > 0 or #cfg.postbuildcommands > 0 then %>\n				<ExtraCommands>\n					<% for _,v in ipairs(cfg.prebuildcommands) do %>\n					<Add before=\"<%= premake.esc(v) %>\" />\n					<% end %>\n					<% for _,v in ipairs(cfg.postbuildcommands) do %>\n					<Add after=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</ExtraCommands>\n				<% end %>\n			</Target>\n		<% end %>\n		</Build>\n		<% for _,fname in ipairs(this.files) do %>\n		<Unit filename=\"<%= premake.esc(fname) %>\">\n		<% if path.getextension(fname) == \".rc\" then %>\n			<Option compilerVar=\"WINDRES\" />\n		<% elseif path.iscppfile(fname) then %>\n			<Option compilerVar=\"<%= iif(this.language == \"C\", \"CC\", \"CPP\") %>\" />\n			<% if (not this.flags.NoPCH and fname == this.pchheader) then %>\n			<Option compile=\"1\" />\n			<Option weight=\"0\" />\n			<% end %>\n		<% end %>\n		</Unit>\n		<% end %>\n		<Extensions />\n	</Project>\n</CodeBlocks_project_file>\n]])",
	"_TEMPLATES.codelite_workspace=premake.loadtemplatestring('codelite_workspace',[[<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<CodeLite_Workspace Name=\"<%= premake.esc(this.name) %>\" Database=\"./<%= premake.esc(this.name) %>.tags\">\n<% for i,prj in ipairs(this.projects) do %>\n  <Project Name=\"<%= premake.esc(prj.name) %>\" Path=\"<%= path.join(path.getrelative(this.location, prj.location), prj.name) %>.project\" Active=\"<%= iif(i==1, \"Yes\", \"No\") %>\" />\n<% end %>\n  <BuildMatrix>\n  <% for _, cfgname in ipairs(this.configurations) do %>\n    <WorkspaceConfiguration Name=\"<%= cfgname %>\" Selected=\"yes\">\n    <% for _,prj in ipairs(this.projects) do %>\n      <Project Name=\"<%= prj.name %>\" ConfigName=\"<%= cfgname %>\"/>\n    <% end %>\n    </WorkspaceConfiguration>\n  <% end %>\n  </BuildMatrix>\n</CodeLite_Workspace>\n]])",
	"_TEMPLATES.codelite_project=premake.loadtemplatestring('codelite_project',[[<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<CodeLite_Project Name=\"<%= premake.esc(this.name) %>\">\n  <% premake.walksources(this, this.files, _CODELITE.files) %>\n  <Settings Type=\"<%= _CODELITE.kind(this.kind) %>\">\n  <% for cfg in premake.eachconfig(this) do %>\n    <Configuration Name=\"<%= premake.esc(cfg.name) %>\" CompilerType=\"gnu <%= iif(cfg.language == \"C\", \"gcc\", \"g++\") %>\" DebuggerType=\"GNU gdb debugger\" Type=\"<%= _CODELITE.kind(cfg.kind) %>\">\n      <General OutputFile=\"<%= premake.esc(cfg.buildtarget.fullpath) %>\" IntermediateDirectory=\"<%= premake.esc(cfg.objectsdir) %>\" Command=\"./<%= cfg.buildtarget.name %>\" CommandArguments=\"\" WorkingDirectory=\"<%= cfg.buildtarget.directory %>\" PauseExecWhenProcTerminates=\"<%= iif(cfg.kind == \"WindowedApp\", \"no\", \"yes\") %>\"/>\n      <Compiler Required=\"yes\" Options=\"<%= table.concat(table.join(premake.gcc.getcflags(cfg), premake.gcc.getcxxflags(cfg), cfg.buildoptions), \";\") %>\">\n        <% for _,v in ipairs(cfg.includedirs) do %>\n        <IncludePath Value=\"<%= premake.esc(v) %>\"/>\n        <% end %>\n        <% for _,v in ipairs(cfg.defines) do %>\n        <Preprocessor Value=\"<%= premake.esc(v) %>\"/>\n        <% end %>\n      </Compiler>\n      <Linker Required=\"yes\" Options=\"<%= table.concat(premake.esc(table.join(premake.gcc.getldflags(cfg), cfg.linkoptions)), \";\") %>\">\n        <% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"directory\")) do %>\n        <LibraryPath Value=\"<%= premake.esc(v) %>\" />\n        <% end %>\n        <% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"basename\")) do %>\n        <Library Value=\"<%= premake.esc(v) %>\" />\n        <% end %>\n      </Linker>\n      <% if premake.findfile(cfg, \".rc\") then %>\n      <ResourceCompiler Required=\"yes\" Options=\"<%= table.implode(table.join(cfg.defines,cfg.resdefines), \"-D\", \";\", \"\") %><%= table.concat(cfg.resoptions, \";\") %>\">\n        <% for _,v in ipairs(table.join(cfg.includedirs, cfg.resincludedirs)) do %>\n        <IncludePath Value=\"<%= premake.esc(v) %>\"/>\n        <% end %>\n      </ResourceCompiler>\n      <% else %>\n      <ResourceCompiler Required=\"no\" Options=\"\"/>\n      <% end %>\n      <% if #cfg.prebuildcommands > 0 then %>\n      <PreBuild>\n        <% for _,v in ipairs(cfg.prebuildcommands) do %>\n        <Command Enabled=\"yes\"><%= premake.esc(v) %></Command>\n        <% end %>\n      </PreBuild>\n      <% end %>\n      <% if #cfg.postbuildcommands > 0 then %>\n      <PostBuild>\n        <% for _,v in ipairs(cfg.postbuildcommands) do %>\n        <Command Enabled=\"yes\"><%= premake.esc(v) %></Command>\n        <% end %>\n      </PostBuild>\n      <% end %>\n      <CustomBuild Enabled=\"no\">\n        <CleanCommand></CleanCommand>\n        <BuildCommand></BuildCommand>\n        <SingleFileCommand></SingleFileCommand>\n        <MakefileGenerationCommand></MakefileGenerationCommand>\n        <ThirdPartyToolName>None</ThirdPartyToolName>\n        <WorkingDirectory></WorkingDirectory>\n      </CustomBuild>\n      <AdditionalRules>\n        <CustomPostBuild></CustomPostBuild>\n        <CustomPreBuild></CustomPreBuild>\n      </AdditionalRules>\n    </Configuration>\n  <%end %>\n  </Settings>\n  <% for _,cfgname in ipairs(this.configurations) do %>\n  <Dependencies name=\"<%= cfgname %>\">\n    <% for _,dep in ipairs(premake.getdependencies(this)) do %>\n    <Project Name=\"<%= dep.name %>\"/>\n    <% end %>\n  </Dependencies>\n  <% end %>\n</CodeLite_Project>\n]])",
	"--\n\n\n\nlocal function cleantemplatefiles(this, templates)\nif (templates) then\nfor _,tmpl in ipairs(templates) do\nlocal fname = premake.getoutputname(this, tmpl[1])\nos.remove(fname)\nend\nend\nend\n\n\n\nnewaction {\ntrigger     = \"clean\",\ndescription = \"Remove all binaries and generated files\",\ntargetstyle = \"windows\",\n\nexecute = function()\nlocal solutions = { }\nlocal projects = { }\nlocal targets = { }\n\nlocal cwd = os.getcwd()\nlocal function rebase(parent, dir)\nreturn path.rebase(dir, parent.location, cwd)\nend\n\n-- Walk the tree. Build a list of object names to pass to the cleaners,\n-- and delete any toolset agnostic files along the way.\nfor _,sln in ipairs(_SOLUTIONS) do\ntable.insert(solutions, path.join(sln.location, sln.name))\n\nfor prj in premake.eachproject(sln) do\ntable.insert(projects, path.join(prj.location, prj.name))\n\nif (prj.objectsdir) then\nos.rmdir(rebase(prj, prj.objectsdir))\nend\n\nfor cfg in premake.eachconfig(prj) do\ntable.insert(targets, path.join(rebase(cfg, cfg.buildtarget.directory), cfg.buildtarget.basename))\n\n-- remove all possible permutations of the target binary\nos.remove(rebase(cfg, premake.gettarget(cfg, \"build\", \"windows\").fullpath))\nos.remove(rebase(cfg, premake.gettarget(cfg, \"build\", \"linux\", \"linux\").fullpath))\nos.remove(rebase(cfg, premake.gettarget(cfg, \"build\", \"linux\", \"macosx\").fullpath))\nif (cfg.kind == \"WindowedApp\") then\nos.rmdir(rebase(cfg, premake.gettarget(cfg, \"build\", \"linux\", \"linux\").fullpath .. \".app\"))\nend\n\n-- if there is an import library, remove that too\nos.remove(rebase(cfg, premake.gettarget(cfg, \"link\", \"windows\").fullpath))\nos.remove(rebase(cfg, premake.gettarget(cfg, \"link\", \"linux\").fullpath))\n\nos.rmdir(rebase(cfg, cfg.objectsdir))\nend\nend\nend\n\n-- Walk the tree again. Delete templated and toolset-specific files\nfor _,action in pairs(premake.actions) do\nfor _,sln in ipairs(_SOLUTIONS) do\ncleantemplatefiles(sln, action.solutiontemplates)\nfor prj in premake.eachproject(sln) do\ncleantemplatefiles(prj, action.projecttemplates)\nend\nend\n\nif (type(action.onclean) == \"function\") then\naction.onclean(solutions, projects, targets)\nend\nend\nend,\n}\n",
	"--\n\n\nnewaction {\ntrigger         = \"codeblocks\",\nshortname       = \"Code::Blocks\",\ndescription     = \"Code::Blocks Studio\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\" },\n\nvalid_tools     = {\ncc   = { \"gcc\", \"ow\" },\n},\n\nsolutiontemplates = {\n{ \".workspace\",  _TEMPLATES.codeblocks_workspace },\n},\n\nprojecttemplates = {\n{ \".cbp\", _TEMPLATES.codeblocks_cbp },\n},\n\nonclean = function(solutions, projects, targets)\nfor _,name in ipairs(projects) do\nos.remove(name .. \".depend\")\nos.remove(name .. \".layout\")\nend\nend\n}\n",
	"--\n\n_CODELITE = { }\n\n\n\nfunction _CODELITE.kind(value)\nif (value == \"ConsoleApp\" or value == \"WindowedApp\") then\nreturn \"Executable\"\nelseif (value == \"StaticLib\") then\nreturn \"Static Library\"\nelseif (value == \"SharedLib\") then\nreturn \"Dynamic Library\"\nend\nend\n\n\n\n\nfunction _CODELITE.files(prj, fname, state, nestlevel)\nlocal indent = string.rep(\"  \", nestlevel + 1)\n\nif (state == \"GroupStart\") then\nio.write(indent .. '<VirtualDirectory Name=\"' .. path.getname(fname) .. '\">\\n')\nelseif (state == \"GroupEnd\") then\nio.write(indent .. '</VirtualDirectory>\\n')\nelse\nio.write(indent .. '<File Name=\"' .. fname .. '\"/>\\n')\nend\nend\n\n\n\nnewaction {\ntrigger         = \"codelite\",\nshortname       = \"CodeLite\",\ndescription     = \"CodeLite (experimental)\",\ntargetstyle     = \"linux\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\" },\n\nvalid_tools     = {\ncc   = { \"gcc\" },\n},\n\nsolutiontemplates = {\n{ \".workspace\",  _TEMPLATES.codelite_workspace },\n},\n\nprojecttemplates = {\n{ \".project\",  _TEMPLATES.codelite_project },\n},\n\nonclean = function(solutions, projects, targets)\nfor _,name in ipairs(solutions) do\nos.remove(name .. \"_wsp.mk\")\nos.remove(name .. \".tags\")\nend\nfor _,name in ipairs(projects) do\nos.remove(name .. \".mk\")\nos.remove(name .. \".list\")\nos.remove(name .. \".out\")\nend\nend\n}\n",
	"--\n\n_MAKE = { }\n\n\n\nfunction _MAKE.esc(value)\nif (type(value) == \"table\") then\nlocal result = { }\nfor _,v in ipairs(value) do\ntable.insert(result, _MAKE.esc(v))\nend\nreturn result\nelse\nlocal result\nresult = value:gsub(\" \", \"\\\\ \")\nresult = result:gsub(\"\\\\\", \"\\\\\\\\\")\nreturn result\nend\nend\n\n\n\n\nfunction _MAKE.getmakefilename(this, searchprjs)\n-- how many projects/solutions use this location?\nlocal count = 0\nfor _,sln in ipairs(_SOLUTIONS) do\nif (sln.location == this.location) then count = count + 1 end\nif (searchprjs) then\nfor _,prj in ipairs(sln.projects) do\nif (prj.location == this.location) then count = count + 1 end\nend\nend\nend\n\nif (count == 1) then\nreturn \"Makefile\"\nelse\nreturn this.name .. \".make\"\nend\nend\n\n\n\nfunction _MAKE.getnames(tbl)\nlocal result = table.extract(tbl, \"name\")\nfor k,v in pairs(result) do\nresult[k] = _MAKE.esc(v)\nend\nreturn result\nend\n\n\n\nnewaction {\ntrigger         = \"gmake\",\nshortname       = \"GNU Make\",\ndescription     = \"GNU makefiles for POSIX, MinGW, and Cygwin\",\ntargetstyle     = \"linux\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nvalid_tools     = {\ncc     = { \"gcc\" },\ndotnet = { \"mono\", \"ms\", \"pnet\" },\n},\n\nsolutiontemplates = {\n{\nfunction(this) return _MAKE.getmakefilename(this, false) end,  \npremake.make_solution\n},\n},\n\nprojecttemplates = {\n{ \nfunction(this) return _MAKE.getmakefilename(this, true) end,   \npremake.make_cpp,\nfunction(this) return this.language == \"C\" or this.language == \"C++\" end\n},\n{\nfunction(this) return _MAKE.getmakefilename(this, true) end,\npremake.make_csharp,\nfunction(this) return this.language == \"C#\" end\n},\n},\n}\n",
	"--\n\n_VS = { }\n\n\n\npremake.vstudio_platforms = { \nany     = \"Any CPU\", \nmixed   = \"Mixed Platforms\", \nNative  = \"Win32\",\nx32     = \"Win32\", \nx64     = \"x64\",\nXbox360 = \"Xbox 360\",\n}\n\n\n\n\nfunction _VS.arch(prj)\nif (prj.language == \"C#\") then\nif (_ACTION < \"vs2005\") then\nreturn \".NET\"\nelse\nreturn \"Any CPU\"\nend\nelse\nreturn \"Win32\"\nend\nend\n\n\n\n\nfunction _VS.bool(value)\nif (_ACTION < \"vs2005\") then\nreturn iif(value, \"TRUE\", \"FALSE\")\nelse\nreturn iif(value, \"true\", \"false\")\nend\nend\n\n\n\n\nfunction _VS.cfgtype(cfg)\nif (cfg.kind == \"SharedLib\") then\nreturn 2\nelseif (cfg.kind == \"StaticLib\") then\nreturn 4\nelse\nreturn 1\nend\nend\n\n\n\n\nfunction premake.vstudio_filterplatforms(sln)\nlocal supported = iif(_ACTION < \"vs2005\", {}, premake.vstudio_platforms)\nreturn premake.filterplatforms(sln, supported, \"x32\")\nend\n\n\n\n\nfunction _VS.onclean(solutions, projects, targets)\nfor _,name in ipairs(solutions) do\nos.remove(name .. \".suo\")\nos.remove(name .. \".ncb\")\nend\n\nfor _,name in ipairs(projects) do\nos.remove(name .. \".csproj.user\")\nos.remove(name .. \".csproj.webinfo\")\n\nlocal files = os.matchfiles(name .. \".vcproj.*.user\", name .. \".csproj.*.user\")\nfor _, fname in ipairs(files) do\nos.remove(fname)\nend\nend\n\nfor _,name in ipairs(targets) do\nos.remove(name .. \".pdb\")\nos.remove(name .. \".idb\")\nos.remove(name .. \".ilk\")\nos.remove(name .. \".vshost.exe\")\nos.remove(name .. \".exe.manifest\")\nend\nend\n\n\n\n\nlocal function output(indent, value)\nio.write(indent .. value .. \"\\r\\n\")\nend\n\nlocal function attrib(indent, name, value)\nio.write(indent .. \"\\t\" .. name .. '=\"' .. value .. '\"\\r\\n')\nend\n\nfunction _VS.files(prj, fname, state, nestlevel)\nlocal indent = string.rep(\"\\t\", nestlevel + 2)\n\nif (state == \"GroupStart\") then\noutput(indent, \"<Filter\")\nattrib(indent, \"Name\", path.getname(fname))\nattrib(indent, \"Filter\", \"\")\noutput(indent, \"\\t>\")\n\nelseif (state == \"GroupEnd\") then\noutput(indent, \"</Filter>\")\n\nelse\noutput(indent, \"<File\")\nattrib(indent, \"RelativePath\", path.translate(fname, \"\\\\\"))\noutput(indent, \"\\t>\")\nif (not prj.flags.NoPCH and prj.pchsource == fname) then\nfor _, cfgname in ipairs(prj.configurations) do\noutput(indent, \"\\t<FileConfiguration\")\nattrib(indent, \"\\tName\", cfgname .. \"|Win32\")\noutput(indent, \"\\t\\t>\")\noutput(indent, \"\\t\\t<Tool\")\nattrib(indent, \"\\t\\tName\", \"VCCLCompilerTool\")\nattrib(indent, \"\\t\\tUsePrecompiledHeader\", \"1\")\noutput(indent, \"\\t\\t/>\")\noutput(indent, \"\\t</FileConfiguration>\")\nend\nend\noutput(indent, \"</File>\")\nend\nend\n\n\n\n\nfunction _VS.optimization(cfg)\nlocal result = 0\nfor _, value in ipairs(cfg.flags) do\nif (value == \"Optimize\") then\nresult = 3\nelseif (value == \"OptimizeSize\") then\nresult = 1\nelseif (value == \"OptimizeSpeed\") then\nresult = 2\nend\nend\nreturn result\nend\n\n\n\n\nfunction _VS.projectfile(prj)\nlocal extension\nif (prj.language == \"C#\") then\nextension = \".csproj\"\nelse\nextension = \".vcproj\"\nend\n\nlocal fname = path.join(prj.location, prj.name)\nreturn fname..extension\nend\n\n\n\n\nfunction _VS.runtime(cfg)\nlocal debugbuild = (_VS.optimization(cfg) == 0)\nif (cfg.flags.StaticRuntime) then\nreturn iif(debugbuild, 1, 0)\nelse\nreturn iif(debugbuild, 3, 2)\nend\nend\n\n\n\n\nfunction _VS.symbols(cfg)\nif (not cfg.flags.Symbols) then\nreturn 0\nelse\n-- Edit-and-continue does't work if optimizing or managed C++\nif (cfg.flags.NoEditAndContinue or _VS.optimization(cfg) ~= 0 or cfg.flags.Managed) then\nreturn 3\nelse\nreturn 4\nend\nend\nend\n\n\n\n\nfunction _VS.tool(prj)\nif (prj.language == \"C#\") then\nreturn \"FAE04EC0-301F-11D3-BF4B-00C04F79EFBC\"\nelse\nreturn \"8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942\"\nend\nend\n\n\n\n\n\nnewaction {\ntrigger         = \"vs2002\",\nshortname       = \"Visual Studio 2002\",\ndescription     = \"Microsoft Visual Studio 2002\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",         premake.vs2002_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\",      premake.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\",      premake.vs2002_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", premake.vs2002_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n\nnewaction {\ntrigger         = \"vs2003\",\nshortname       = \"Visual Studio 2003\",\ndescription     = \"Microsoft Visual Studio 2003\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",         premake.vs2003_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\",      premake.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\",      premake.vs2002_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", premake.vs2002_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n\nnewaction {\ntrigger         = \"vs2005\",\nshortname       = \"Visual Studio 2005\",\ndescription     = \"Microsoft Visual Studio 2005 (SharpDevelop, MonoDevelop)\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",         premake.vs2005_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\",      premake.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\",      premake.vs2005_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", premake.vs2005_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n\nnewaction {\ntrigger         = \"vs2008\",\nshortname       = \"Visual Studio 2008\",\ndescription     = \"Microsoft Visual Studio 2008\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",         premake.vs2005_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\",      premake.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\",      premake.vs2005_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", premake.vs2005_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n",
	0
};
