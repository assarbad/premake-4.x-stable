/* Premake's Lua scripts, as static data buffers for release mode builds */
/* To regenerate this file, run: premake4 embed */ 

const char* builtin_scripts[] = {
	"--\n\n\n\nfunction os.findlib(libname)\nlocal path, formats\n\n-- assemble a search path, depending on the platform\nif os.is(\"windows\") then\nformats = { \"%s.dll\", \"%s\" }\npath = os.getenv(\"PATH\")\nelse\nif os.is(\"macosx\") then\nformats = { \"lib%s.dylib\", \"%s.dylib\" }\npath = os.getenv(\"DYLD_LIBRARY_PATH\")\nelse\nformats = { \"lib%s.so\", \"%s.so\" }\npath = os.getenv(\"LD_LIBRARY_PATH\") or \"\"\n\nlocal f = io.open(\"/etc/ld.so.conf\", \"r\")\nif f then\nfor line in f:lines() do\npath = path .. \":\" .. line\nend\nf:close()\nend\nend\n\ntable.insert(formats, \"%s\")\npath = (path or \"\") .. \":/lib:/usr/lib:/usr/local/lib\"\nend\n\nfor _, fmt in ipairs(formats) do\nlocal name = string.format(fmt, libname)\nlocal result = os.pathsearch(name, path)\nif result then return result end\nend\nend\n\n\n\n\nfunction os.get()\nreturn _OPTIONS.os or _OS\nend\n\n\n\n\nfunction os.is(id)\nreturn (os.get():lower() == id:lower())\nend\n\n\n\n\nlocal function domatch(result, mask, wantfiles)\nlocal basedir = path.getdirectory(mask)\nif (basedir == \".\") then basedir = \"\" end\n\nlocal m = os.matchstart(mask)\nwhile (os.matchnext(m)) do\nlocal fname = os.matchname(m)\nlocal isfile = os.matchisfile(m)\nif ((wantfiles and isfile) or (not wantfiles and not isfile)) then\ntable.insert(result, path.join(basedir, fname))\nend\nend\nos.matchdone(m)\n\n-- if the mask uses \"**\", recurse subdirectories\nif (mask:find(\"**\", nil, true)) then\nmask = path.getname(mask)\nm = os.matchstart(path.join(basedir, \"*\"))\nwhile (os.matchnext(m)) do\nlocal dirname = os.matchname(m)\nlocal submask = path.join(path.join(basedir, dirname), mask)\ndomatch(result, submask, wantfiles)\nend\nos.matchdone(m)\nend\nend\n\nfunction os.matchdirs(...)\nlocal result = { }\nfor _, mask in ipairs(arg) do\ndomatch(result, mask, false)\nend\nreturn result\nend\n\nfunction os.matchfiles(...)\nlocal result = { }\nfor _, mask in ipairs(arg) do\ndomatch(result, mask, true)\nend\nreturn result\nend\n\n\n\n\nlocal builtin_mkdir = os.mkdir\nfunction os.mkdir(p)\nlocal dir = iif(p:startswith(\"/\"), \"/\", \"\")\nfor part in p:gmatch(\"[^/]+\") do\ndir = dir .. part\n\nif (part ~= \"\" and not path.isabsolute(part) and not os.isdir(dir)) then\nlocal ok, err = builtin_mkdir(dir)\nif (not ok) then\nreturn nil, err\nend\nend\n\ndir = dir .. \"/\"\nend\n\nreturn true\nend\n\n\n\nlocal builtin_rmdir = os.rmdir\nfunction os.rmdir(p)\n-- recursively remove subdirectories\nlocal dirs = os.matchdirs(p .. \"/*\")\nfor _, dname in ipairs(dirs) do\nos.rmdir(dname)\nend\n\n-- remove any files\nlocal files = os.matchfiles(p .. \"/*\")\nfor _, fname in ipairs(files) do\nos.remove(fname)\nend\n\n-- remove this directory\nbuiltin_rmdir(p)\nend\n\n",
	"--\n\n\npath = { }\n\n\n\nfunction path.getabsolute(p)\n-- normalize the target path\np = path.translate(p, \"/\")\nif (p == \"\") then p = \".\" end\n\n-- if the directory is already absolute I don't need to do anything\nlocal result = iif (path.isabsolute(p), nil, os.getcwd())\n\n-- split up the supplied relative path and tackle it bit by bit\nfor _,part in ipairs(p:explode(\"/\", true)) do\nif (part == \"\") then\nresult = \"/\"\nelseif (part == \"..\") then\nresult = path.getdirectory(result)\nelseif (part ~= \".\") then\nresult = path.join(result, part)\nend\nend\n\nreturn result\nend\n\n\n\nfunction path.getbasename(p)\nlocal name = path.getname(p)\nlocal i = name:findlast(\".\", true)\nif (i) then\nreturn name:sub(1, i - 1)\nelse\nreturn name\nend\nend\n\n\n\nfunction path.getdirectory(p)\nlocal i = p:findlast(\"/\", true)\nif (i) then\nif i > 1 then i = i - 1 end\nreturn p:sub(1, i)\nelse\nreturn \".\"\nend\nend\n\n\n\nfunction path.getdrive(p)\nlocal ch1 = p:sub(1,1)\nlocal ch2 = p:sub(2,2)\nif ch2 == \":\" then\nreturn ch1\nend\nend\n\n\n\n\nfunction path.getextension(p)\nlocal i = p:findlast(\".\", true)\nif (i) then\nreturn p:sub(i)\nelse\nreturn \"\"\nend\nend\n\n\n\n\nfunction path.getname(p)\nlocal i = p:findlast(\"[/\\\\]\")\nif (i) then\nreturn p:sub(i + 1)\nelse\nreturn p\nend\nend\n\n\n\nfunction path.getrelative(src, dst)\n-- normalize the two paths\nsrc = path.getabsolute(src)\ndst = path.getabsolute(dst)\n\n-- same directory?\nif (src == dst) then\nreturn \".\"\nend\n\n-- different drives? Must use absolute path\nif path.getdrive(src) ~= path.getdrive(dst) then\nreturn dst\nend\n\nsrc = src .. \"/\"\ndst = dst .. \"/\"\n\n-- trim off the common directories from the front \nlocal i = src:find(\"/\")\nwhile (i) do\nif (src:sub(1,i) == dst:sub(1,i)) then\nsrc = src:sub(i + 1)\ndst = dst:sub(i + 1)\nelse\nbreak\nend\ni = src:find(\"/\")\nend\n\n-- back up from dst to get to this common parent\nlocal result = \"\"\ni = src:find(\"/\")\nwhile (i) do\nresult = result .. \"../\"\ni = src:find(\"/\", i + 1)\nend\n\n-- tack on the path down to the dst from here\nresult = result .. dst\n\n-- remove the trailing slash\nreturn result:sub(1, -2)\nend\n\n\n\nfunction path.isabsolute(p)\nlocal ch1 = p:sub(1,1)\nlocal ch2 = p:sub(2,2)\nreturn (ch1 == \"/\" or ch1 == \"\\\\\" or ch2 == \":\")\nend\n\n\n\nfunction path.iscfile(fname)\nlocal extensions = { \".c\", \".s\" }\nlocal ext = path.getextension(fname):lower()\nreturn table.contains(extensions, ext)\nend\n\nfunction path.iscppfile(fname)\nlocal extensions = { \".cc\", \".cpp\", \".cxx\", \".c\", \".s\" }\nlocal ext = path.getextension(fname):lower()\nreturn table.contains(extensions, ext)\nend\n\n\n\nfunction path.isresourcefile(fname)\nlocal extensions = { \".rc\" }\nlocal ext = path.getextension(fname):lower()\nreturn table.contains(extensions, ext)\nend\n\n\n\n\nfunction path.join(leading, trailing)\nif (not leading) then \nleading = \"\" \nend\n\nif (not trailing) then\nreturn leading\nend\n\nif (path.isabsolute(trailing)) then\nreturn trailing\nend\n\nif (leading == \".\") then\nleading = \"\"\nend\n\nif (leading:len() > 0 and not leading:endswith(\"/\")) then\nleading = leading .. \"/\"\nend\n\nreturn leading .. trailing\nend\n\n\n\nfunction path.rebase(p, oldbase, newbase)\np = path.getabsolute(path.join(oldbase, p))\np = path.getrelative(newbase, p)\nreturn p\nend\n\n\n\nfunction path.translate(p, sep)\nif (type(p) == \"table\") then\nlocal result = { }\nfor _, value in ipairs(p) do\ntable.insert(result, path.translate(value))\nend\nreturn result\nelse\nif (not sep) then\nif (os.is(\"windows\")) then\nsep = \"\\\\\"\nelse\nsep = \"/\"\nend\nend\nlocal result = p:gsub(\"[/\\\\]\", sep)\nreturn result\nend\nend\n",
	"--\n\n\n\nfunction string.endswith(haystack, needle)\nif (haystack and needle) then\nlocal hlen = haystack:len()\nlocal nlen = needle:len()\nif (hlen >= nlen) then\nreturn (haystack:sub(-nlen) == needle)\nend\nend\n\nreturn false\nend\n\n\n\nfunction string.explode(s, pattern, plain)\nif (pattern == '') then return false end\nlocal pos = 0\nlocal arr = { }\nfor st,sp in function() return s:find(pattern, pos, plain) end do\ntable.insert(arr, s:sub(pos, st-1))\npos = sp + 1\nend\ntable.insert(arr, s:sub(pos))\nreturn arr\nend\n\n\n\n\nfunction string.findlast(s, pattern, plain)\nlocal curr = 0\nrepeat\nlocal next = s:find(pattern, curr + 1, plain)\nif (next) then curr = next end\nuntil (not next)\nif (curr > 0) then\nreturn curr\nend\nend\n\n\n\n\nfunction string.startswith(haystack, needle)\nreturn (haystack:find(needle, 1, true) == 1)\nend",
	"--\n\n\n\nfunction table.contains(t, value)\nfor _,v in pairs(t) do\nif (v == value) then\nreturn true\nend\nend\nreturn false\nend\n\n\n\nfunction table.extract(arr, fname)\nlocal result = { }\nfor _,v in ipairs(arr) do\ntable.insert(result, v[fname])\nend\nreturn result\nend\n\n\n\n\nfunction table.implode(arr, before, after, between)\nlocal result = \"\"\nfor _,v in ipairs(arr) do\nif (result ~= \"\" and between) then\nresult = result .. between\nend\nresult = result .. before .. v .. after\nend\nreturn result\nend\n\n\n\nfunction table.join(...)\nlocal result = { }\nfor _,t in ipairs(arg) do\nif type(t) == \"table\" then\nfor _,v in ipairs(t) do\ntable.insert(result, v)\nend\nelse\ntable.insert(result, t)\nend\nend\nreturn result\nend\n\n\n\nfunction table.translate(arr, translation)\nlocal result = { }\nfor _, value in ipairs(arr) do\nlocal tvalue\nif type(translation) == \"function\" then\ntvalue = translation(value)\nelse\ntvalue = translation[value]\nend\nif (tvalue) then\ntable.insert(result, tvalue)\nend\nend\nreturn result\nend\n\n",
	"--\n\n\n\n_SOLUTIONS = { }\n\n\n\n_TEMPLATES = { }\n\n\n\npremake = { }\n\n\n\npremake.actions = { }\npremake.options = { }\n\n\n\n\nlocal builtin_dofile = dofile\nfunction dofile(fname)\n-- remember the current working directory; I'll restore it shortly\nlocal oldcwd = os.getcwd()\n\n-- if the file doesn't exist, check the search path\nif (not os.isfile(fname)) then\nlocal path = os.pathsearch(fname, _OPTIONS[\"scripts\"], os.getenv(\"PREMAKE_PATH\"))\nif (path) then\nfname = path..\"/\"..fname\nend\nend\n\n-- use the absolute path to the script file, to avoid any file name\n-- ambiguity if an error should arise\nfname = path.getabsolute(fname)\n\n-- switch the working directory to the new script location\nlocal newcwd = path.getdirectory(fname)\nos.chdir(newcwd)\n\n-- run the chunk. How can I catch variable return values?\nlocal a, b, c, d, e, f = builtin_dofile(fname)\n\n-- restore the previous working directory when done\nos.chdir(oldcwd)\nreturn a, b, c, d, e, f\nend\n\n\n\n\nfunction iif(expr, trueval, falseval)\nif (expr) then\nreturn trueval\nelse\nreturn falseval\nend\nend\n\n\n\n\nfunction include(fname)\nreturn dofile(fname .. \"/premake4.lua\")\nend\n\n\n\n\nlocal builtin_open = io.open\nfunction io.open(fname, mode)\nif (mode) then\nif (mode:find(\"w\")) then\nlocal dir = path.getdirectory(fname)\nok, err = os.mkdir(dir)\nif (not ok) then\nerror(err, 0)\nend\nend\nend\nreturn builtin_open(fname, mode)\nend\n\n\n\n\nfunction printf(msg, ...)\nprint(string.format(msg, unpack(arg)))\nend\n\n\n\n\nlocal builtin_type = type\nfunction type(t)\nlocal mt = getmetatable(t)\nif (mt) then\nif (mt.__type) then\nreturn mt.__type\nend\nend\nreturn builtin_type(t)\nend\n",
	"--\n\n\n\nlocal function literal(str)\nlocal code = \"\"\n\nfor line in str:gmatch(\"[^\\n]*\") do\nif (line:len() > 0) then\ncode = code .. \"io.write[=[\" .. line .. \"]=]\"\nelse\ncode = code .. \"io.write(eol)\\n\"\nend\nend\n\nreturn code:sub(1, -15)\nend\n\n\n\n\nfunction premake.encodetemplate(tmpl)\ncode = \"\"\n\n-- normalize line endings\ntmpl = tmpl:gsub(\"\\r\\n\", \"\\n\")\n\nwhile (true) do\n-- find an escaped block\nstart, finish = tmpl:find(\"<%%.-%%>\")\nif (not start) then break end\n\nlocal before = tmpl:sub(1, start - 1)\nlocal after  = tmpl:sub(finish + 1)\n\n-- get the block type and contents\nlocal block\nlocal isexpr = (tmpl:sub(start + 2, start + 2) == \"=\")\nif (isexpr) then\nblock = tmpl:sub(start + 3, finish - 2)\nelse\nblock = tmpl:sub(start + 2, finish - 2)\nend\n\n-- if a statement block, strip out everything else on that line\nif (not isexpr) then\nfinish = before:findlast(\"\\n\", true)\nif (finish) then \nbefore = before:sub(1, finish)\nelse\nbefore = nil\nend\n\nstart = after:find(\"\\n\", 1, true)\nif (start) then \nafter = after:sub(start + 1) \nend\nend\n\n-- output everything before the block\nif (before) then\ncode = code .. literal(before)\nend\n\n-- output the block itself\nif (isexpr) then\ncode = code .. \"io.write(\" .. block .. \")\"\nelse\ncode = code .. block .. \"\\n\"\nend\n\n-- do it again, with everything after the block\ntmpl = after\nend\n\n-- tack on everything after the last block\ncode = code .. literal(tmpl)\nreturn code\nend\n\n\n\n\nfunction premake.loadtemplatestring(name, str)\nlocal code = premake.encodetemplate(str)\nlocal fn, msg = loadstring(\"return function (this) eol='\\\\n';\" .. code .. \" end\", name)\nif (not fn) then\nerror(msg, 0)\nend\nreturn fn()\nend\n\n\n\n\nfunction premake.getoutputname(this, namespec)\nlocal fname\nif (type(namespec) == \"function\") then\nfname = namespec(this)\nelse\nfname = this.name .. namespec\nend\nreturn path.join(this.location, fname)\nend\n\n\n\n\nfunction premake.loadtemplatefile(fname)\nlocal f = io.open(fname, \"rb\")\nlocal tmpl = f:read(\"*a\")\nf:close()\nreturn premake.loadtemplatestring(path.getname(fname), tmpl)\nend\n\n",
	"--\n\n\n\n\nfunction premake.eachconfig(prj)\n-- I probably have the project root config, rather than the actual project\nif prj.project then prj = prj.project end\nlocal i = 0\nlocal t = prj.solution.configurations\nreturn function ()\ni = i + 1\nif (i <= #t) then\nreturn prj.__configs[t[i]]\nend\nend\nend\n\n\n\n\nfunction premake.eachfile(prj)\n-- project root config contains the file config list\nif not prj.project then prj = premake.getconfig(prj) end\nlocal i = 0\nlocal t = prj.files\nreturn function ()\ni = i + 1\nif (i <= #t) then\nreturn prj.__fileconfigs[t[i]]\nend\nend\nend\n\n\n\n\nfunction premake.eachproject(sln)\nlocal i = 0\nreturn function ()\ni = i + 1\nif (i <= #sln.projects) then\nlocal prj = sln.projects[i]\nlocal cfg = premake.getconfig(prj)\ncfg.name  = prj.name\ncfg.blocks = prj.blocks\nreturn cfg\nend\nend\nend\n\n\n\n\nfunction premake.esc(value)\nif (type(value) == \"table\") then\nlocal result = { }\nfor _,v in ipairs(value) do\ntable.insert(result, premake.esc(v))\nend\nreturn result\nelse\nvalue = value:gsub('&',  \"&amp;\")\nvalue = value:gsub('\"',  \"&quot;\")\nvalue = value:gsub(\"'\",  \"&apos;\")\nvalue = value:gsub('<',  \"&lt;\")\nvalue = value:gsub('>',  \"&gt;\")\nvalue = value:gsub('\\r', \"&#x0D;\")\nvalue = value:gsub('\\n', \"&#x0A;\")\nreturn value\nend\nend\n\n\n\n\nfunction premake.findproject(name)\nname = name:lower()\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nif (prj.name:lower() == name) then\nreturn prj\nend\nend\nend\nend\n\n\n\n\nfunction premake.findfile(prj, extension)\nfor _, fname in ipairs(prj.files) do\nif fname:endswith(extension) then return fname end\nend\nend\n\n\n\n\nfunction premake.getconfig(prj, cfgname)\n-- might have the root configuration, rather than the actual project\nif prj.project then prj = prj.project end\nreturn prj.__configs[cfgname or \"\"]\nend\n\n\n\n\nfunction premake.getdependencies(cfg)\nlocal results = { }\nfor _, link in ipairs(cfg.links) do\nlocal prj = premake.findproject(link)\nif (prj) then\ntable.insert(results, prj)\nend\nend\nreturn results\nend\n\n\n\n\nfunction premake.getlinks(cfg, kind, part)\n-- if I'm building a list of link directories, include libdirs\nlocal result = iif (part == \"directory\" and kind == \"all\", cfg.libdirs, {})\n\n-- am I getting links for a configuration or a project?\nlocal cfgname = iif(cfg.name == cfg.project.name, \"\", cfg.name)\n\nlocal function canlink(source, target)\nif (target.kind ~= \"SharedLib\" and target.kind ~= \"StaticLib\") then return false end\nif (source.language == \"C\" or source.language == \"C++\") then\nif (target.language ~= \"C\" and target.language ~= \"C++\") then return false end\nreturn true\nelseif (source.language == \"C#\") then\nif (target.language ~= \"C#\") then return false end\nreturn true\nend\nend\n\nfor _, link in ipairs(cfg.links) do\nlocal item\n\n-- is this a sibling project?\nlocal prj = premake.findproject(link)\nif prj and kind ~= \"system\" then\n\nlocal prjcfg = premake.getconfig(prj, cfgname)\nif kind == \"dependencies\" or canlink(cfg, prjcfg) then\nif (part == \"directory\") then\nitem = path.rebase(prjcfg.linktarget.directory, prjcfg.location, cfg.location)\nelseif (part == \"basename\") then\nitem = prjcfg.linktarget.basename\nelseif (part == \"fullpath\") then\nitem = path.rebase(prjcfg.linktarget.fullpath, prjcfg.location, cfg.location)\nelseif (part == \"object\") then\nitem = prjcfg\nend\nend\n\nelseif not prj and (kind == \"system\" or kind == \"all\") then\n\nif (part == \"directory\") then\nlocal dir = path.getdirectory(link)\nif (dir ~= \".\") then\nitem = dir\nend\nelseif (part == \"fullpath\") then\nitem = link\nif premake.actions[_ACTION].targetstyle == \"windows\" then\nitem = item .. iif(cfg.language == \"C\" or cfg.language == \"C++\", \".lib\", \".dll\")\nend\nif item:find(\"/\", nil, true) then\nitem = path.getrelative(cfg.basedir, item)\nend\nelse\nitem = link\nend\n\nend\n\nif item then\nif premake.actions[_ACTION].targetstyle == \"windows\" and part ~= \"object\" then\nitem = path.translate(item, \"\\\\\")\nend\nif not table.contains(result, item) then\ntable.insert(result, item)\nend\nend\nend\n\nreturn result\nend\n\n\n\n\nfunction premake.gettarget(cfg, direction, style, os)\n-- normalize the arguments\nif not os then os = _G[\"os\"].get() end\nif (os == \"bsd\") then os = \"linux\" end\n\nlocal kind = cfg.kind\nif (cfg.language == \"C\" or cfg.language == \"C++\") then\n-- On Windows, shared libraries link against a static import library\nif (style == \"windows\" or os == \"windows\") and kind == \"SharedLib\" and direction == \"link\" then\nkind = \"StaticLib\"\nend\n\n-- Linux name conventions only apply to static libs on windows (by user request)\nif (style == \"linux\" and os == \"windows\" and kind ~= \"StaticLib\") then\nstyle = \"windows\"\nend\nelseif (cfg.language == \"C#\") then\n-- .NET always uses Windows naming conventions\nstyle = \"windows\"\nend\n\n-- Initialize the target components\nlocal field   = iif(direction == \"build\", \"target\", \"implib\")\nlocal name    = cfg[field..\"name\"] or cfg.targetname or cfg.project.name\nlocal dir     = cfg[field..\"dir\"] or cfg.targetdir or path.getrelative(cfg.location, cfg.basedir)\nlocal prefix  = \"\"\nlocal suffix  = \"\"\n\n-- If using an import library and \"NoImportLib\" flag is set, library will be in objdir\nif cfg.kind == \"SharedLib\" and kind == \"StaticLib\" and cfg.flags.NoImportLib then\ndir = cfg.objectsdir\nend\n\nif style == \"windows\" then\nif kind == \"ConsoleApp\" or kind == \"WindowedApp\" then\nsuffix = \".exe\"\nelseif kind == \"SharedLib\" then\nsuffix = \".dll\"\nelseif kind == \"StaticLib\" then\nsuffix = \".lib\"\nend\nelseif style == \"linux\" then\nif (kind == \"WindowedApp\" and os == \"macosx\") then\ndir = path.join(dir, name .. \".app/Contents/MacOS\")\nelseif kind == \"SharedLib\" then\nprefix = \"lib\"\nsuffix = \".so\"\nelseif kind == \"StaticLib\" then\nprefix = \"lib\"\nsuffix = \".a\"\nend\nend\n\nprefix = cfg[field..\"prefix\"] or cfg.targetprefix or prefix\nsuffix = cfg[field..\"extension\"] or cfg.targetextension or suffix\n\nlocal result = { }\nresult.basename  = name\nresult.name      = prefix .. name .. suffix\nresult.directory = dir\nresult.fullpath  = path.join(result.directory, result.name)\nreturn result\nend\n\n\n\nlocal function walksources(prj, files, fn, group, nestlevel, finished)\nlocal grouplen = group:len()\nlocal gname = iif(group:endswith(\"/\"), group:sub(1,-2), group)\n\n-- open this new group\nif (nestlevel >= 0) then\nfn(prj, gname, \"GroupStart\", nestlevel)\nend\n\n-- scan the list of files for items which belong in this group\nfor _,fname in ipairs(files) do\nif (fname:startswith(group)) then\n\n-- is there a subgroup within this item?\nlocal _,split = fname:find(\"[^\\.]/\", grouplen + 1)\nif (split) then\nlocal subgroup = fname:sub(1, split)\nif (not finished[subgroup]) then\nfinished[subgroup] = true\nwalksources(prj, files, fn, subgroup, nestlevel + 1, finished)\nend\nend\n\nend\nend\n\n-- process all files that belong in this group\nfor _,fname in ipairs(files) do\nif (fname:startswith(group) and not fname:find(\"/\", grouplen + 1, true)) then\nfn(prj, fname, \"GroupItem\", nestlevel + 1)\nend\nend\n\n-- close the group\nif (nestlevel >= 0) then\nfn(prj, gname, \"GroupEnd\", nestlevel)\nend\nend\n\n\nfunction premake.walksources(prj, files, fn)\nwalksources(prj, files, fn, \"\", -1, {})\nend\n",
	"--\n\n\n-- do not copy these fields into the configurations\nlocal nocopy = \n{\nblocks   = true,\nkeywords = true,\nprojects = true,\n}\n\n-- leave these paths as absolute, rather than converting to project relative\nlocal nofixup =\n{\nbasedir  = true,\nlocation = true,\n}\n\n\n\n\nfunction premake.getactiveterms()\nlocal terms = { _ACTION:lower(), os.get() }\n\n-- add option keys or values\nfor key, value in pairs(_OPTIONS) do\nif value ~= \"\" then\ntable.insert(terms, value:lower())\nelse\ntable.insert(terms, key:lower())\nend\nend\n\nreturn terms\nend\n\n\n\n\nfunction premake.escapekeyword(keyword)\nkeyword = keyword:gsub(\"([%.%-%^%$%(%)%%])\", \"%%%1\")\nif keyword:find(\"**\", nil, true) then\nkeyword = keyword:gsub(\"%*%*\", \".*\")\nelse\nkeyword = keyword:gsub(\"%*\", \"[^/]*\")\nend\nreturn keyword:lower()\nend\n\n\n\n\nfunction premake.iskeywordmatch(keyword, terms)\n-- is it negated?\nif keyword:startswith(\"not \") then\nreturn not premake.iskeywordmatch(keyword:sub(5), terms)\nend\n\nfor _, word in ipairs(keyword:explode(\" or \")) do\nlocal pattern = \"^\" .. word .. \"$\"\nfor termkey, term in pairs(terms) do\nif term:match(pattern) then\nreturn termkey\nend\nend\nend\nend\n\n\n\n\nfunction premake.iskeywordsmatch(keywords, terms)\nlocal hasrequired = false\nfor _, keyword in ipairs(keywords) do\nlocal matched = premake.iskeywordmatch(keyword, terms)\nif not matched then\nreturn false\nend\nif matched == \"required\" then\nhasrequired = true\nend\nend\n\nif terms.required and not hasrequired then\nreturn false\nelse\nreturn true\nend\nend\n\n\n\n\nlocal function copyfields(cfg, this)\nfor field,value in pairs(this) do\nif (not nocopy[field]) then\nif (type(value) == \"table\") then\nif (not cfg[field]) then cfg[field] = { } end\ncfg[field] = table.join(cfg[field], value) \nelse\ncfg[field] = value\nend\nend\nend\nend\n\n\n\n\nlocal function buildconfig(prj, terms)\n-- fields are copied first from the solution, then the solution's configs,\n-- then from the project, then the project's configs. Each can overwrite\n-- or add to the values set previously. The objdir field gets special\n-- treatment, in order to provide a project-level default and still enable\n-- solution-level overrides\n\nlocal cfg = { }\n\ncopyfields(cfg, prj.solution)\nfor _,blk in ipairs(prj.solution.blocks) do\nif (premake.iskeywordsmatch(blk.keywords, terms)) then\ncopyfields(cfg, blk)\nend\nend\n\ncopyfields(cfg, prj)\nfor _,blk in ipairs(prj.blocks) do\nif (premake.iskeywordsmatch(blk.keywords, terms)) then\ncopyfields(cfg, blk)\nend\nend\n\nreturn cfg\nend\n\n\n\n\nlocal function buildprojectconfig(prj, cfgname)\n-- create the base configuration, flattening the list of objects and\n-- filtering out settings which do not match the current environment\nlocal terms = premake.getactiveterms()\nterms.config = (cfgname or \"\"):lower()\n\nlocal cfg   = buildconfig(prj, terms)\ncfg.name    = cfgname\ncfg.project = prj\n\n-- set the project location, if not already set\ncfg.location = cfg.location or cfg.basedir\n\n-- remove excluded files from the file list\nlocal files = { }\nfor _, fname in ipairs(cfg.files) do\nlocal excluded = false\nfor _, exclude in ipairs(cfg.excludes) do\nexcluded = (fname == exclude)\nif (excluded) then break end\nend\n\nif (not excluded) then\ntable.insert(files, fname)\nend\nend\ncfg.files = files\n\n-- fixup the data\nfor name, field in pairs(premake.fields) do\n-- convert absolute paths to project relative\nif (field.kind == \"path\" or field.kind == \"dirlist\" or field.kind == \"filelist\") and (not nofixup[name]) then\nif type(cfg[name]) == \"table\" then\nfor i,p in ipairs(cfg[name]) do cfg[name][i] = path.getrelative(prj.location, p) end\nelse\nif cfg[name] then cfg[name] = path.getrelative(prj.location, cfg[name]) end\nend\nend\n\n-- re-key flag fields for faster lookups\nif field.isflags then\nlocal values = cfg[name]\nfor _, flag in ipairs(values) do values[flag] = true end\nend\nend\n\n-- build configuration objects for all files\ncfg.__fileconfigs = { }\nfor _, fname in ipairs(cfg.files) do\nterms.required = fname:lower()\nlocal fcfg = buildconfig(prj, terms)\nfcfg.name = fname\n-- add indexed by name and integer\ncfg.__fileconfigs[fname] = fcfg\ntable.insert(cfg.__fileconfigs, fcfg)\nend\n\nreturn cfg\nend\n\n\n\n\nlocal function buildtargets(cfg)\n\n-- deduce and store the applicable tool for this configuration\nif cfg.language == \"C\" or cfg.language == \"C++\" then\nif _OPTIONS.cc then cfg.tool = premake[_OPTIONS.cc] end\nelseif cfg.language == \"C#\" then\nif _OPTIONS.dotnet then cfg.tool = premake[_OPTIONS.dotnet] end\nend\n\n-- deduce the target and path style from the current action/tool pairing\nlocal action = premake.actions[_ACTION]\nlocal targetstyle = action.targetstyle or \"linux\"\nif (cfg.tool) then\ntargetstyle = cfg.tool.targetstyle or targetstyle\nend\n\n-- build a unique objects directory\nlocal function getbasedir(cfg)\nreturn path.join(cfg.location, cfg.objdir or cfg.project.objdir or \"obj\")\nend\n\nlocal function getuniquedir(cfg)\nlocal thisbase  = getbasedir(cfg)\nlocal thislocal = path.join(thisbase, cfg.name)\nlocal isbasematched = false\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nfor _, thatcfg in pairs(prj.__configs) do\nif thatcfg ~= cfg then\nlocal thatbase = getbasedir(thatcfg)\nif thisbase == thatbase then\nisbasematched = true\nif thislocal == path.join(thatbase, thatcfg.name) then\nreturn path.join(thislocal, cfg.project.name)\nend\nend\nend\nend\nend\nend\n\nreturn iif(isbasematched, thislocal, thisbase)\nend\n\ncfg.objectsdir = path.getrelative(cfg.location, getuniquedir(cfg))\n\n-- precompute the target names and paths\ncfg.buildtarget = premake.gettarget(cfg, \"build\", targetstyle)\ncfg.linktarget  = premake.gettarget(cfg, \"link\",  targetstyle)\n\n-- translate the paths as appropriate\nlocal pathstyle = action.pathstyle or targetstyle\nif (pathstyle == \"windows\") then\ncfg.buildtarget.directory = path.translate(cfg.buildtarget.directory, \"\\\\\")\ncfg.buildtarget.fullpath  = path.translate(cfg.buildtarget.fullpath, \"\\\\\")\ncfg.linktarget.directory = path.translate(cfg.linktarget.directory, \"\\\\\")\ncfg.linktarget.fullpath  = path.translate(cfg.linktarget.fullpath, \"\\\\\")\ncfg.objectsdir = path.translate(cfg.objectsdir, \"\\\\\")\nend\nend\n\n\n\n\nfunction premake.buildconfigs()\n-- walk the object tree once and flatten the configurations\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nprj.__configs = { }\nprj.__configs[\"\"] = buildprojectconfig(prj)\nfor _, name in ipairs(sln.configurations) do\nprj.__configs[name] = buildprojectconfig(prj, name)\nend\nend\nend\n\n-- walk it again and build the targets and unique directories\nfor _, sln in ipairs(_SOLUTIONS) do\nfor _, prj in ipairs(sln.projects) do\nfor _, cfg in pairs(prj.__configs) do\nbuildtargets(cfg)\nend\nend\nend\nend\n",
	"--\n\n\n\npremake.fields = \n{\nbasedir =\n{\nkind  = \"path\",\nscope = \"container\",\n},\n\nbuildaction =\n{\nkind  = \"string\",\nscope = \"config\",\nallowed = {\n\"Compile\",\n\"Copy\",\n\"Embed\",\n\"None\"\n}\n},\n\nbuildoptions =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nconfigurations = \n{\nkind  = \"list\",\nscope = \"solution\",\n},\n\ndefines =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nexcludes =\n{\nkind  = \"filelist\",\nscope = \"config\",\n},\n\nfiles =\n{\nkind  = \"filelist\",\nscope = \"config\",\n},\n\nflags =\n{\nkind  = \"list\",\nscope = \"config\",\nisflags = true,\nallowed = {\n\"ExtraWarnings\",\n\"FatalWarnings\",\n\"Managed\",\n\"NativeWChar\",\n\"No64BitChecks\",\n\"NoEditAndContinue\",\n\"NoExceptions\",\n\"NoFramePointer\",\n\"NoImportLib\",\n\"NoManifest\",\n\"NoNativeWChar\",\n\"NoPCH\",\n\"NoRTTI\",\n\"Optimize\",\n\"OptimizeSize\",\n\"OptimizeSpeed\",\n\"SEH\",\n\"StaticRuntime\",\n\"Symbols\",\n\"Unicode\",\n\"Unsafe\",\n\"WinMain\"\n}\n},\n\nimplibdir =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\nimplibextension =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nimplibname =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nimplibprefix =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nincludedirs =\n{\nkind  = \"dirlist\",\nscope = \"config\",\n},\n\nkind =\n{\nkind  = \"string\",\nscope = \"config\",\nallowed = {\n\"ConsoleApp\",\n\"WindowedApp\",\n\"StaticLib\",\n\"SharedLib\"\n}\n},\n\nlanguage =\n{\nkind  = \"string\",\nscope = \"container\",\nallowed = {\n\"C\",\n\"C++\",\n\"C#\"\n}\n},\n\nlibdirs =\n{\nkind  = \"dirlist\",\nscope = \"config\",\n},\n\nlinkoptions =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nlinks =\n{\nkind  = \"list\",\nscope = \"config\",\nallowed = function(value)\n-- if library name contains a '/' then treat it as a path to a local file\nif value:find('/', nil, true) then\nvalue = path.getabsolute(value)\nend\nreturn value\nend\n\n},\n\nlocation =\n{\nkind  = \"path\",\nscope = \"container\",\n},\n\nobjdir =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\npchheader =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\npchsource =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\npostbuildcommands =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nprebuildcommands =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nprelinkcommands =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nresdefines =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\nresincludedirs =\n{\nkind  = \"dirlist\",\nscope = \"config\",\n},\n\nresoptions =\n{\nkind  = \"list\",\nscope = \"config\",\n},\n\ntargetdir =\n{\nkind  = \"path\",\nscope = \"config\",\n},\n\ntargetextension =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\ntargetname =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\ntargetprefix =\n{\nkind  = \"string\",\nscope = \"config\",\n},\n\nuuid =\n{\nkind  = \"string\",\nscope = \"container\",\nallowed = function(value)\nlocal ok = true\nif (#value ~= 36) then ok = false end\nfor i=1,36 do\nlocal ch = value:sub(i,i)\nif (not ch:find(\"[ABCDEFabcdef0123456789-]\")) then ok = false end\nend\nif (value:sub(9,9) ~= \"-\")   then ok = false end\nif (value:sub(14,14) ~= \"-\") then ok = false end\nif (value:sub(19,19) ~= \"-\") then ok = false end\nif (value:sub(24,24) ~= \"-\") then ok = false end\nif (not ok) then\nreturn nil, \"invalid UUID\"\nend\nreturn value:upper()\nend\n},\n}\n\n\n\n\n\n\nlocal function checkvalue(value, allowed)\nif (allowed) then\nif (type(allowed) == \"function\") then\nreturn allowed(value)\nelse\nfor _,v in ipairs(allowed) do\nif (value:lower() == v:lower()) then\nreturn v\nend\nend\nreturn nil, \"invalid value '\" .. value .. \"'\"\nend\nelse\nreturn value\nend\nend\n\n\n\n\nfunction premake.getobject(t)\nlocal container\n\nif (t == \"container\" or t == \"solution\") then\ncontainer = premake.CurrentContainer\nelse\ncontainer = premake.CurrentConfiguration\nend\n\nif t == \"solution\" then\nif type(container) == \"project\" then\ncontainer = container.solution\nend\nif type(container) ~= \"solution\" then\ncontainer = nil\nend\nend\n\nlocal msg\nif (not container) then\nif (t == \"container\") then\nmsg = \"no active solution or project\"\nelseif (t == \"solution\") then\nmsg = \"no active solution\"\nelse\nmsg = \"no active solution, project, or configuration\"\nend\nend\n\nreturn container, msg\nend\n\n\n\n\nfunction premake.setarray(ctype, fieldname, value, allowed)\nlocal container, err = premake.getobject(ctype)\nif (not container) then\nerror(err, 4)\nend\n\nif (not container[fieldname]) then\ncontainer[fieldname] = { }\nend\n\nlocal function doinsert(value, depth)\nif (type(value) == \"table\") then\nfor _,v in ipairs(value) do\ndoinsert(v, depth + 1)\nend\nelse\nvalue, err = checkvalue(value, allowed)\nif (not value) then\nerror(err, depth)\nend\ntable.insert(container[fieldname], value)\nend\nend\n\nif (value) then\ndoinsert(value, 5)\nend\n\nreturn container[fieldname]\nend\n\n\n\n\nlocal function domatchedarray(ctype, fieldname, value, matchfunc)\nlocal result = { }\n\nfunction makeabsolute(value)\nif (type(value) == \"table\") then\nfor _,item in ipairs(value) do\nmakeabsolute(item)\nend\nelse\nif value:find(\"*\") then\nmakeabsolute(matchfunc(value))\nelse\ntable.insert(result, path.getabsolute(value))\nend\nend\nend\n\nmakeabsolute(value)\nreturn premake.setarray(ctype, fieldname, result)\nend\n\nfunction premake.setdirarray(ctype, fieldname, value)\nreturn domatchedarray(ctype, fieldname, value, os.matchdirs)\nend\n\nfunction premake.setfilearray(ctype, fieldname, value)\nreturn domatchedarray(ctype, fieldname, value, os.matchfiles)\nend\n\n\n\n\nfunction premake.setstring(ctype, fieldname, value, allowed)\n-- find the container for this value\nlocal container, err = premake.getobject(ctype)\nif (not container) then\nerror(err, 4)\nend\n\n-- if a value was provided, set it\nif (value) then\nvalue, err = checkvalue(value, allowed)\nif (not value) then \nerror(err, 4)\nend\n\ncontainer[fieldname] = value\nend\n\nreturn container[fieldname]\nend\n\n\n\n\nlocal function accessor(name, value)\nlocal kind    = premake.fields[name].kind\nlocal scope   = premake.fields[name].scope\nlocal allowed = premake.fields[name].allowed\n\nif (kind == \"string\") then\nreturn premake.setstring(scope, name, value, allowed)\nelseif (kind == \"path\") then\nif value then value = path.getabsolute(value) end\nreturn premake.setstring(scope, name, value)\nelseif (kind == \"list\") then\nreturn premake.setarray(scope, name, value, allowed)\nelseif (kind == \"dirlist\") then\nreturn premake.setdirarray(scope, name, value)\nelseif (kind == \"filelist\") then\nreturn premake.setfilearray(scope, name, value)\nend\nend\n\n\n\n\nfor name,_ in pairs(premake.fields) do\n_G[name] = function(value)\nreturn accessor(name, value)\nend\nend\n\n\n\n\nfunction configuration(keywords)\nif not keywords then\nreturn premake.CurrentConfiguration\nend\n\nlocal container, err = premake.getobject(\"container\")\nif (not container) then\nerror(err, 2)\nend\n\nlocal cfg = { }\ntable.insert(container.blocks, cfg)\npremake.CurrentConfiguration = cfg\n\n-- create a keyword list using just the indexed keyword items\ncfg.keywords = { }\nfor _, word in ipairs(table.join({}, keywords)) do\ntable.insert(cfg.keywords, premake.escapekeyword(word))\nend\n\n-- if file patterns are specified, convert them to Lua patterns and add them too\nif keywords.files then\nfor _, pattern in ipairs(table.join({}, keywords.files)) do\npattern = pattern:gsub(\"%.\", \"%%.\")\nif pattern:find(\"**\", nil, true) then\npattern = pattern:gsub(\"%*%*\", \".*\")\nelse\npattern = pattern:gsub(\"%*\", \"[^/]*\")\nend\ntable.insert(cfg.keywords, \"^\" .. pattern .. \"$\")\nend\nend\n\n-- initialize list-type fields to empty tables\nfor name, field in pairs(premake.fields) do\nif (field.kind ~= \"string\" and field.kind ~= \"path\") then\ncfg[name] = { }\nend\nend\n\nreturn cfg\nend\n\n\nfunction project(name)\nif not name then\nreturn iif(type(premake.CurrentContainer) == \"project\", premake.CurrentContainer, nil)\nend\n\n-- identify the parent solution\nlocal sln\nif (type(premake.CurrentContainer) == \"project\") then\nsln = premake.CurrentContainer.solution\nelse\nsln = premake.CurrentContainer\nend\nif (type(sln) ~= \"solution\") then\nerror(\"no active solution\", 2)\nend\n\n-- if this is a new project, create it\npremake.CurrentContainer = sln.projects[name]\nif (not premake.CurrentContainer) then\nlocal prj = { }\npremake.CurrentContainer = prj\n\n-- add to master list keyed by both name and index\ntable.insert(sln.projects, prj)\nsln.projects[name] = prj\n\n-- attach a type\nsetmetatable(prj, {\n__type = \"project\",\n})\n\nprj.solution       = sln\nprj.name           = name\nprj.basedir        = os.getcwd()\nprj.location       = prj.basedir\nprj.uuid           = os.uuid()\nprj.blocks         = { }\nend\n\n-- add an empty, global configuration to the project\nconfiguration { }\n\nreturn premake.CurrentContainer\nend\n\n\nfunction solution(name)\nif not name then\nif type(premake.CurrentContainer) == \"project\" then\nreturn premake.CurrentContainer.solution\nelse\nreturn premake.CurrentContainer\nend\nend\n\npremake.CurrentContainer = _SOLUTIONS[name]\nif (not premake.CurrentContainer) then\nlocal sln = { }\npremake.CurrentContainer = sln\n\n-- add to master list keyed by both name and index\ntable.insert(_SOLUTIONS, sln)\n_SOLUTIONS[name] = sln\n\n-- attach a type\nsetmetatable(sln, { \n__type=\"solution\"\n})\n\nsln.name           = name\nsln.location       = os.getcwd()\nsln.projects       = { }\nsln.blocks         = { }\nsln.configurations = { }\nend\n\n-- add an empty, global configuration\nconfiguration { }\n\nreturn premake.CurrentContainer\nend\n\n\n",
	"--\n\n\nlocal requiredactionfields =\n{\n\"description\",\n\"trigger\",\n}\n\nlocal requiredoptionfields = \n{\n\"description\",\n\"trigger\"\n}\n\n\n\nfunction newaction(a)\n-- some sanity checking\nlocal missing\nfor _, field in ipairs(requiredactionfields) do\nif (not a[field]) then\nmissing = field\nend\nend\n\nif (missing) then\nerror(\"action needs a \" .. missing, 2)\nend\n\n-- add it to the master list\npremake.actions[a.trigger] = a\nend\n\n\n\n\nfunction newoption(opt)\n-- some sanity checking\nlocal missing\nfor _, field in ipairs(requiredoptionfields) do\nif (not opt[field]) then\nmissing = field\nend\nend\n\nif (missing) then\nerror(\"action needs a \" .. missing, 2)\nend\n\n-- add it to the master list\npremake.options[opt.trigger] = opt\nend\n\n\n\n\nnewoption \n{\ntrigger     = \"cc\",\nvalue       = \"compiler\",\ndescription = \"Choose a C/C++ compiler set\",\nallowed = {\n{ \"gcc\", \"GNU GCC compiler (gcc/g++)\" },\n{ \"ow\",  \"OpenWatcom compiler\"        },\n}\n}\n\nnewoption\n{\ntrigger     = \"dotnet\",\nvalue       = \"value\",\ndescription = \"Choose a .NET compiler set\",\nallowed = {\n{ \"ms\",      \"Microsoft .NET (csc)\" },\n{ \"mono\",    \"Novell Mono (mcs)\"    },\n{ \"pnet\",    \"Portable.NET (cscc)\"  },\n}\n}\n\nnewoption\n{\ntrigger     = \"file\",\nvalue       = \"filename\",\ndescription = \"Process the specified Premake script file\"\n}\n\nnewoption\n{\ntrigger     = \"help\",\ndescription = \"Display this information\"\n}\n\nnewoption\n{\ntrigger     = \"os\",\nvalue       = \"value\",\ndescription = \"Generate files for a different operating system\",\nallowed = {\n{ \"bsd\",      \"OpenBSD, NetBSD, or FreeBSD\" },\n{ \"linux\",    \"Linux\" },\n{ \"macosx\",   \"Apple Mac OS X\" },\n{ \"windows\",  \"Microsoft Windows\" },\n}\n}\n\nnewoption\n{\ntrigger     = \"scripts\",\nvalue       = \"path\",\ndescription = \"Search for additional scripts on the given path\"\n}\n\nnewoption\n{\ntrigger     = \"version\",\ndescription = \"Display version information\"\n}\n",
	"--\n\n\npremake.csc = { }\n\n\n\nlocal flags =\n{\nFatalWarning   = \"/warnaserror\",\nOptimize       = \"/optimize\",\nOptimizeSize   = \"/optimize\",\nOptimizeSpeed  = \"/optimize\",\nSymbols        = \"/debug\",\nUnsafe         = \"/unsafe\"\n}\n\n\n\nfunction premake.csc.getbuildaction(fcfg)\nlocal ext = path.getextension(fcfg.name):lower()\nif fcfg.buildaction == \"Compile\" or ext == \".cs\" then\nreturn \"Compile\"\nelseif fcfg.buildaction == \"Embed\" or ext == \".resx\" then\nreturn \"EmbeddedResource\"\nelseif fcfg.buildaction == \"Copy\" or ext == \".asax\" or ext == \".aspx\" then\nreturn \"Content\"\nelse\nreturn \"None\"\nend\nend\n\n\n\n\nfunction premake.csc.getcompilervar(cfg)\nif (_OPTIONS.dotnet == \"ms\") then\nreturn \"csc\"\nelseif (_OPTIONS.dotnet == \"mono\") then\nreturn \"gmcs\"\nelse\nreturn \"cscc\"\nend\nend\n\n\n\n\nfunction premake.csc.getflags(cfg)\nlocal result = table.translate(cfg.flags, flags)\nreturn result\nend\n\n\n\n\nfunction premake.csc.getkind(cfg)\nif (cfg.kind == \"ConsoleApp\") then\nreturn \"Exe\"\nelseif (cfg.kind == \"WindowedApp\") then\nreturn \"WinExe\"\nelseif (cfg.kind == \"SharedLib\") then\nreturn \"Library\"\nend\nend",
	"--\n\n\npremake.gcc = { }\npremake.targetstyle = \"linux\"\n\n\n\nlocal cflags =\n{\nExtraWarnings  = \"-Wall\",\nFatalWarning   = \"-Werror\",\nNoFramePointer = \"-fomit-frame-pointer\",\nOptimize       = \"-O2\",\nOptimizeSize   = \"-Os\",\nOptimizeSpeed  = \"-O3\",\nSymbols        = \"-g\",\n}\n\nlocal cxxflags =\n{\nNoExceptions   = \"--no-exceptions\",\nNoRTTI         = \"--no-rtti\",\n}\n\n\n\n\n\nfunction premake.gcc.getcppflags(cfg)\n-- if $(ARCH) contains multiple targets, then disable the incompatible automatic\n-- dependency generation. This allows building universal binaries on MacOSX, sorta.\nreturn \"$(if $(word 2, $(ARCH)), , -MMD)\"\nend\n\nfunction premake.gcc.getcflags(cfg)\nlocal result = table.translate(cfg.flags, cflags)\nif (cfg.kind == \"SharedLib\" and not os.is(\"windows\")) then\ntable.insert(result, \"-fPIC\")\nend\nreturn result\nend\n\nfunction premake.gcc.getcxxflags(cfg)\nlocal result = table.translate(cfg.flags, cxxflags)\nreturn result\nend\n\n\n\n\nfunction premake.gcc.getldflags(cfg)\nlocal result = { }\n\nif (cfg.kind == \"SharedLib\") then\nif os.is(\"macosx\") then\nresult = table.join(result, { \"-dynamiclib\", \"-flat_namespace\" })\nelse\ntable.insert(result, \"-shared\")\nend\n\n-- create import library for DLLs under Windows\nif (os.is(\"windows\") and not cfg.flags.NoImportLib) then\ntable.insert(result, '-Wl,--out-implib=\"'..premake.gettarget(cfg, \"link\", \"linux\").fullpath..'\"')\nend\nend\n\nif (os.is(\"windows\") and cfg.kind == \"WindowedApp\") then\ntable.insert(result, \"-mwindows\")\nend\n\n-- OS X has a bug, see http://lists.apple.com/archives/Darwin-dev/2006/Sep/msg00084.html\nif (not cfg.flags.Symbols) then\nif (os.is(\"macosx\")) then\ntable.insert(result, \"-Wl,-x\")\nelse\ntable.insert(result, \"-s\")\nend\nend\n\nreturn result\nend\n\n\n\nfunction premake.gcc.getlinkflags(cfg)\nlocal result = { }\nfor _, value in ipairs(premake.getlinks(cfg, \"all\", \"directory\")) do\ntable.insert(result, '-L' .. _MAKE.esc(value))\nend\nfor _, value in ipairs(premake.getlinks(cfg, \"all\", \"basename\")) do\ntable.insert(result, '-l' .. _MAKE.esc(value))\nend\nreturn result\nend\n\n\n\n\nfunction premake.gcc.getdefines(defines)\nlocal result = { }\nfor _,def in ipairs(defines) do\ntable.insert(result, '-D' .. def)\nend\nreturn result\nend\n\n\n\n\nfunction premake.gcc.getincludedirs(includedirs)\nlocal result = { }\nfor _,dir in ipairs(includedirs) do\ntable.insert(result, \"-I\" .. _MAKE.esc(dir))\nend\nreturn result\nend\n",
	"--\n\npremake.ow = { }\npremake.ow.targetstyle = \"windows\"\n\n\n\nlocal cflags =\n{\nExtraWarnings  = \"-wx\",\nFatalWarning   = \"-we\",\nOptimize       = \"-ox\",\nOptimizeSize   = \"-os\",\nOptimizeSpeed  = \"-ot\",\nSymbols        = \"-d2\",\n}\n\nlocal cxxflags =\n{\nNoExceptions   = \"-xd\",\nNoRTTI         = \"-xr\",\n}\n\n\n\n\n\nfunction premake.ow.getcppflags(cfg)\nreturn \"\"\nend\n\nfunction premake.ow.getcflags(cfg)\nlocal result = table.translate(cfg.flags, cflags)\nif (cfg.flags.Symbols) then\ntable.insert(result, \"-hw\")   -- Watcom debug format for Watcom debugger\nend\nreturn result\nend\n\nfunction premake.ow.getcxxflags(cfg)\nlocal result = table.translate(cfg.flags, cxxflags)\nreturn result\nend\n\n\n\n\nfunction premake.ow.getldflags(cfg)\nlocal result = { }\n\nif (cfg.flags.Symbols) then\ntable.insert(result, \"op symf\")\nend\n\nreturn result\nend\n\n\n\nfunction premake.ow.getlinkflags(cfg)\nlocal result = { }\nreturn result\nend\n\n\n\n\nfunction premake.ow.getdefines(defines)\nlocal result = { }\nfor _,def in ipairs(defines) do\ntable.insert(result, '-D' .. def)\nend\nreturn result\nend\n\n\n\n\nfunction premake.ow.getincludedirs(includedirs)\nlocal result = { }\nfor _,dir in ipairs(includedirs) do\ntable.insert(result, '-I \"' .. dir .. '\"')\nend\nreturn result\nend\n\n",
	"--\n\n\n\nfunction premake.checkoptions()\nfor key, value in pairs(_OPTIONS) do\n-- is this a valid option?\nlocal opt = premake.options[key]\nif (not opt) then\nreturn false, \"invalid option '\" .. key .. \"'\"\nend\n\n-- does it need a value?\nif (opt.value and value == \"\") then\nreturn false, \"no value specified for option '\" .. key .. \"'\"\nend\n\n-- is the value allowed?\nif (opt.allowed) then\nfor _, match in ipairs(opt.allowed) do\nif (match[1] == value) then return true end\nend\nreturn false, \"invalid value '\" .. value .. \"' for option '\" .. key .. \"'\"\nend\nend\nreturn true\nend\n\n\n\n\nfunction premake.checkprojects()\nlocal action = premake.actions[_ACTION]\n\nfor _, sln in ipairs(_SOLUTIONS) do\n\n-- every solution must have at least one project\nif (#sln.projects == 0) then\nreturn nil, \"solution '\" .. sln.name .. \"' needs at least one project\"\nend\n\n-- every solution must provide a list of configurations\nif (#sln.configurations == 0) then\nreturn nil, \"solution '\" .. sln.name .. \"' needs configurations\"\nend\n\nfor prj in premake.eachproject(sln) do\n\n-- every project must have a language\nif (not prj.language) then\nreturn nil, \"project '\" ..prj.name .. \"' needs a language\"\nend\n\n-- and the action must support it\nif (action.valid_languages) then\nif (not table.contains(action.valid_languages, prj.language)) then\nreturn nil, \"the \" .. action.shortname .. \" action does not support \" .. prj.language .. \" projects\"\nend\nend\n\nfor cfg in premake.eachconfig(prj) do\n\n-- every config must have a kind\nif (not cfg.kind) then\nreturn nil, \"project '\" ..prj.name .. \"' needs a kind in configuration '\" .. cfgname .. \"'\"\nend\n\n-- and the action must support it\nif (action.valid_kinds) then\nif (not table.contains(action.valid_kinds, cfg.kind)) then\nreturn nil, \"the \" .. action.shortname .. \" action does not support \" .. cfg.kind .. \" projects\"\nend\nend\n\nend\nend\nend\nreturn true\nend\n\n\n\nfunction premake.checktools()\nlocal action = premake.actions[_ACTION]\nif (not action.valid_tools) then \nreturn true \nend\n\nfor tool, values in pairs(action.valid_tools) do\nif (_OPTIONS[tool]) then\nif (not table.contains(values, _OPTIONS[tool])) then\nreturn nil, \"the \" .. action.shortname .. \" action does not support /\" .. tool .. \"=\" .. _OPTIONS[tool] .. \" (yet)\"\nend\nelse\n_OPTIONS[tool] = values[1]\nend\nend\n\nreturn true\nend\n",
	"--\n\n\nfunction premake.showhelp()\n\n-- sort the lists of actions and options into alphabetical order\nactions = { }\nfor name,_ in pairs(premake.actions) do table.insert(actions, name) end\ntable.sort(actions)\n\noptions = { }\nfor name,_ in pairs(premake.options) do table.insert(options, name) end\ntable.sort(options)\n\n\n-- display the basic usage\nprintf(\"Premake %s, a build script generator\", _PREMAKE_VERSION)\nprintf(_PREMAKE_COPYRIGHT)\nprintf(\"%s %s\", _VERSION, _COPYRIGHT)\nprintf(\"\")\nprintf(\"Usage: premake4 [options] action [arguments]\")\nprintf(\"\")\n\n\n-- display all options\nprintf(\"OPTIONS\")\nprintf(\"\")\nfor _,name in ipairs(options) do\nlocal opt = premake.options[name]\nlocal trigger = opt.trigger\nlocal description = opt.description\n\nif (opt.value) then trigger = trigger .. \"=\" .. opt.value end\nif (opt.allowed) then description = description .. \"; one of:\" end\n\nprintf(\" --%-15s %s\", trigger, description) \nif (opt.allowed) then\ntable.sort(opt.allowed, function(a,b) return a[1] < b[1] end)\nfor _, value in ipairs(opt.allowed) do\nprintf(\"     %-14s %s\", value[1], value[2])\nend\nend\nprintf(\"\")\nend\n\n-- display all actions\nprintf(\"ACTIONS\")\nprintf(\"\")\nfor _,name in ipairs(actions) do\nprintf(\" %-17s %s\", name, premake.actions[name].description)\nend\nprintf(\"\")\n\n\n-- see more\nprintf(\"For additional information, see http://industriousone.com/premake\")\n\nend\n\n\n",
	"--\n\n\nlocal scriptfile    = \"premake4.lua\"\nlocal shorthelp     = \"Type 'premake4 --help' for help\"\nlocal versionhelp   = \"premake4 (Premake Build Script Generator) %s\"\n\n\n\n\nlocal function doaction(name)\nlocal action = premake.actions[name]\n\n-- walk the session objects and generate files from the templates\nlocal function generatefiles(this, templates)\nif (not templates) then return end\nfor _,tmpl in ipairs(templates) do\nlocal output = true\nif (tmpl[3]) then\noutput = tmpl[3](this)\nend\nif (output) then\nlocal fname = path.getrelative(os.getcwd(), premake.getoutputname(this, tmpl[1]))\nprintf(\"Generating %s...\", fname)\nlocal f, err = io.open(fname, \"wb\")\nif (not f) then\nerror(err, 0)\nend\nio.output(f)\n\n-- call the template function to generate the output\ntmpl[2](this)\n\nio.output():close()\nend\nend\nend\n\nfor _,sln in ipairs(_SOLUTIONS) do\ngeneratefiles(sln, action.solutiontemplates)\nfor prj in premake.eachproject(sln) do\ngeneratefiles(prj, action.projecttemplates)\nend\nend\n\nif (action.execute) then\naction.execute()\nend\nend\n\n\n\n\nfunction _premake_main(scriptpath)\n\n-- if running off the disk (in debug mode), load everything \n-- listed in _manifest.lua; the list divisions make sure\n-- everything gets initialized in the proper order.\n\nif (scriptpath) then\nlocal scripts, templates, actions  = dofile(scriptpath .. \"/_manifest.lua\")\n\n-- core code first\nfor _,v in ipairs(scripts) do\ndofile(scriptpath .. \"/\" .. v)\nend\n\n-- then the templates\nfor _,v in ipairs(templates) do\nlocal name = path.getbasename(v)\n_TEMPLATES[name] = premake.loadtemplatefile(scriptpath .. \"/\" .. v)\nend\n\n-- finally the actions\nfor _,v in ipairs(actions) do\ndofile(scriptpath .. \"/\" .. v)\nend\nend\n\n\n-- If there is a project script available, run it to get the\n-- project information, available options and actions, etc.\n\nlocal fname = _OPTIONS[\"file\"] or scriptfile\nif (os.isfile(fname)) then\ndofile(fname)\nend\n\n\n-- Process special options\n\nif (_OPTIONS[\"version\"]) then\nprintf(versionhelp, _PREMAKE_VERSION)\nreturn 1\nend\n\nif (_OPTIONS[\"help\"]) then\npremake.showhelp()\nreturn 1\nend\n\n\n-- If no action was specified, show a short help message\n\nif (not _ACTION) then\nprint(shorthelp)\nreturn 1\nend\n\n\n-- If there wasn't a project script I've got to bail now\n\nif (not os.isfile(fname)) then\nerror(\"No Premake script (\"..scriptfile..\") found!\", 2)\nend\n\n\n-- Validate the command-line arguments. This has to happen after the\n-- script has run to allow for project-specific options\n\nif (not premake.actions[_ACTION]) then\nerror(\"Error: no such action '\".._ACTION..\"'\", 0)\nend\n\nok, err = premake.checkoptions()\nif (not ok) then error(\"Error: \" .. err, 0) end\n\n\n-- Sanity check the current project setup\n\nok, err = premake.checktools()\nif (not ok) then error(\"Error: \" .. err, 0) end\n\n-- work-in-progress: build the configurations\nprint(\"Building configurations...\")\npremake.buildconfigs()\n\nok, err = premake.checkprojects()\nif (not ok) then error(\"Error: \" .. err, 0) end\n\n\n-- Hand over control to the action\nprintf(\"Running action '%s'...\", _ACTION)\ndoaction(_ACTION)\n\nprint(\"Done.\")\nreturn 0\n\nend\n",
	"_TEMPLATES.codeblocks_workspace=premake.loadtemplatestring('codeblocks_workspace',[[<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n<CodeBlocks_workspace_file>\n	<Workspace title=\"<%= this.name %>\">\n	<% for prj in premake.eachproject(this) do %>\n		<Project filename=\"<%= path.join(path.getrelative(this.location, prj.location), prj.name) %>.cbp\"<%= iif(prj.project==this.projects[1], ' active=\"1\"', '') %>>\n		<% for _,dep in ipairs(premake.getdependencies(prj)) do %>\n			<Depends filename=\"<%= path.join(path.getrelative(this.location, dep.location), dep.name) %>.cbp\" />\n		<% end %>\n		</Project>\n	<% end %>\n	</Workspace>\n</CodeBlocks_workspace_file>\n]])",
	"_TEMPLATES.codeblocks_cbp=premake.loadtemplatestring('codeblocks_cbp',[[<% local cc = premake[_OPTIONS.cc] %>\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>\n<CodeBlocks_project_file>\n	<FileVersion major=\"1\" minor=\"6\" />\n	<Project>\n		<Option title=\"<%= premake.esc(this.name) %>\" />\n		<Option pch_mode=\"2\" />\n		<Option compiler=\"<%= _OPTIONS.cc %>\" />\n		<Build>\n		<% for cfg in premake.eachconfig(this) do %>\n			<Target title=\"<%= premake.esc(cfg.name) %>\">\n				<Option output=\"<%= premake.esc(cfg.buildtarget.fullpath) %>\" prefix_auto=\"0\" extension_auto=\"0\" />\n				<Option object_output=\"<%= premake.esc(cfg.objectsdir) %>\" />\n				<% if (cfg.kind == \"WindowedApp\") then %>\n				<Option type=\"0\" />\n				<% elseif (cfg.kind == \"ConsoleApp\") then %>\n				<Option type=\"1\" />\n				<% elseif (cfg.kind == \"StaticLib\") then %>\n				<Option type=\"2\" />\n				<% elseif (cfg.kind == \"SharedLib\") then %>\n				<Option type=\"3\" />\n				<% end %>\n				<Option compiler=\"<%= _OPTIONS.cc %>\" />\n				<% if (cfg.kind == \"SharedLib\") then %>\n				<Option createDefFile=\"0\" />\n				<Option createStaticLib=\"<%= iif(cfg.flags.NoImportLib, 0, 1) %>\" />\n				<% end %>\n				<Compiler>\n					<% for _,flag in ipairs(table.join(cc.getcflags(cfg), cc.getcxxflags(cfg), cc.getdefines(cfg.defines), cfg.buildoptions)) do %>\n					<Add option=\"<%= premake.esc(flag) %>\" />\n					<% end %>\n					<% if not cfg.flags.NoPCH and cfg.pchheader then %>\n					<Add option=\"-Winvalid-pch\" />\n					<Add option=\"-include &quot;<%= premake.esc(cfg.pchheader) %>&quot;\" />\n					<% end %>\n					<% for _,v in ipairs(cfg.includedirs) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</Compiler>\n				<Linker>\n					<% if cfg.flags.NoSymbols then %>\n					<Add options=\"-s\" />\n					<% end %>\n					<% for _,v in ipairs(cfg.linkoptions) do %>\n					<Add option=\"<%= premake.esc(v) %>\" />\n					<% end %>\n					<% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"directory\")) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n					<% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"basename\")) do %>\n					<Add library=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</Linker>\n				<% if premake.findfile(cfg, \".rc\") then %>\n				<ResourceCompiler>\n					<% for _,v in ipairs(cfg.includedirs) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n					<% for _,v in ipairs(cfg.resincludedirs) do %>\n					<Add directory=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</ResourceCompiler>\n				<% end %>\n				<% if #cfg.prebuildcommands > 0 or #cfg.postbuildcommands > 0 then %>\n				<ExtraCommands>\n					<% for _,v in ipairs(cfg.prebuildcommands) do %>\n					<Add before=\"<%= premake.esc(v) %>\" />\n					<% end %>\n					<% for _,v in ipairs(cfg.postbuildcommands) do %>\n					<Add after=\"<%= premake.esc(v) %>\" />\n					<% end %>\n				</ExtraCommands>\n				<% end %>\n			</Target>\n		<% end %>\n		</Build>\n		<% for _,fname in ipairs(this.files) do %>\n		<Unit filename=\"<%= premake.esc(fname) %>\">\n		<% if path.getextension(fname) == \".rc\" then %>\n			<Option compilerVar=\"WINDRES\" />\n		<% elseif path.iscppfile(fname) then %>\n			<Option compilerVar=\"<%= iif(this.language == \"C\", \"CC\", \"CPP\") %>\" />\n			<% if (not this.flags.NoPCH and fname == this.pchheader) then %>\n			<Option compile=\"1\" />\n			<Option weight=\"0\" />\n			<% end %>\n		<% end %>\n		</Unit>\n		<% end %>\n		<Extensions />\n	</Project>\n</CodeBlocks_project_file>\n]])",
	"_TEMPLATES.codelite_workspace=premake.loadtemplatestring('codelite_workspace',[[<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<CodeLite_Workspace Name=\"<%= premake.esc(this.name) %>\" Database=\"./<%= premake.esc(this.name) %>.tags\">\n<% for i,prj in ipairs(this.projects) do %>\n  <Project Name=\"<%= premake.esc(prj.name) %>\" Path=\"<%= path.join(path.getrelative(this.location, prj.location), prj.name) %>.project\" Active=\"<%= iif(i==1, \"Yes\", \"No\") %>\" />\n<% end %>\n  <BuildMatrix>\n  <% for _, cfgname in ipairs(this.configurations) do %>\n    <WorkspaceConfiguration Name=\"<%= cfgname %>\" Selected=\"yes\">\n    <% for _,prj in ipairs(this.projects) do %>\n      <Project Name=\"<%= prj.name %>\" ConfigName=\"<%= cfgname %>\"/>\n    <% end %>\n    </WorkspaceConfiguration>\n  <% end %>\n  </BuildMatrix>\n</CodeLite_Workspace>\n]])",
	"_TEMPLATES.codelite_project=premake.loadtemplatestring('codelite_project',[[<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<CodeLite_Project Name=\"<%= premake.esc(this.name) %>\">\n  <% premake.walksources(this, this.files, _CODELITE.files) %>\n  <Settings Type=\"<%= _CODELITE.kind(this.kind) %>\">\n  <% for cfg in premake.eachconfig(this) do %>\n    <Configuration Name=\"<%= premake.esc(cfg.name) %>\" CompilerType=\"gnu <%= iif(cfg.language == \"C\", \"gcc\", \"g++\") %>\" DebuggerType=\"GNU gdb debugger\" Type=\"<%= _CODELITE.kind(cfg.kind) %>\">\n      <General OutputFile=\"<%= premake.esc(cfg.buildtarget.fullpath) %>\" IntermediateDirectory=\"<%= premake.esc(cfg.objectsdir) %>\" Command=\"./<%= cfg.buildtarget.name %>\" CommandArguments=\"\" WorkingDirectory=\"<%= cfg.buildtarget.directory %>\" PauseExecWhenProcTerminates=\"<%= iif(cfg.kind == \"WindowedApp\", \"no\", \"yes\") %>\"/>\n      <Compiler Required=\"yes\" Options=\"<%= table.concat(table.join(premake.gcc.getcflags(cfg), premake.gcc.getcxxflags(cfg), cfg.buildoptions), \";\") %>\">\n        <% for _,v in ipairs(cfg.includedirs) do %>\n        <IncludePath Value=\"<%= premake.esc(v) %>\"/>\n        <% end %>\n        <% for _,v in ipairs(cfg.defines) do %>\n        <Preprocessor Value=\"<%= premake.esc(v) %>\"/>\n        <% end %>\n      </Compiler>\n      <Linker Required=\"yes\" Options=\"<%= table.concat(premake.esc(table.join(premake.gcc.getldflags(cfg), cfg.linkoptions)), \";\") %>\">\n        <% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"directory\")) do %>\n        <LibraryPath Value=\"<%= premake.esc(v) %>\" />\n        <% end %>\n        <% for _,v in ipairs(premake.getlinks(cfg, \"all\", \"basename\")) do %>\n        <Library Value=\"<%= premake.esc(v) %>\" />\n        <% end %>\n      </Linker>\n      <% if premake.findfile(cfg, \".rc\") then %>\n      <ResourceCompiler Required=\"yes\" Options=\"<%= table.implode(table.join(cfg.defines,cfg.resdefines), \"-D\", \";\", \"\") %><%= table.concat(cfg.resoptions, \";\") %>\">\n        <% for _,v in ipairs(table.join(cfg.includedirs, cfg.resincludedirs)) do %>\n        <IncludePath Value=\"<%= premake.esc(v) %>\"/>\n        <% end %>\n      </ResourceCompiler>\n      <% else %>\n      <ResourceCompiler Required=\"no\" Options=\"\"/>\n      <% end %>\n      <% if #cfg.prebuildcommands > 0 then %>\n      <PreBuild>\n        <% for _,v in ipairs(cfg.prebuildcommands) do %>\n        <Command Enabled=\"yes\"><%= premake.esc(v) %></Command>\n        <% end %>\n      </PreBuild>\n      <% end %>\n      <% if #cfg.postbuildcommands > 0 then %>\n      <PostBuild>\n        <% for _,v in ipairs(cfg.postbuildcommands) do %>\n        <Command Enabled=\"yes\"><%= premake.esc(v) %></Command>\n        <% end %>\n      </PostBuild>\n      <% end %>\n      <CustomBuild Enabled=\"no\">\n        <CleanCommand></CleanCommand>\n        <BuildCommand></BuildCommand>\n        <SingleFileCommand></SingleFileCommand>\n        <MakefileGenerationCommand></MakefileGenerationCommand>\n        <ThirdPartyToolName>None</ThirdPartyToolName>\n        <WorkingDirectory></WorkingDirectory>\n      </CustomBuild>\n      <AdditionalRules>\n        <CustomPostBuild></CustomPostBuild>\n        <CustomPreBuild></CustomPreBuild>\n      </AdditionalRules>\n    </Configuration>\n  <%end %>\n  </Settings>\n  <% for _,cfgname in ipairs(this.configurations) do %>\n  <Dependencies name=\"<%= cfgname %>\">\n    <% for _,dep in ipairs(premake.getdependencies(this)) do %>\n    <Project Name=\"<%= dep.name %>\"/>\n    <% end %>\n  </Dependencies>\n  <% end %>\n</CodeLite_Project>\n]])",
	"_TEMPLATES.make_solution=premake.loadtemplatestring('make_solution',[[# <%= premake.actions[_ACTION].shortname %> solution makefile autogenerated by Premake\n# Usage: make [ config=config_name ]\n# Where {config_name} is one of: <%= table.implode(this.configurations, '\"', '\"', ', '):lower() %>.\n\nifndef config\n  config=<%= _MAKE.esc(this.configurations[1]:lower()) %>\nendif\nexport config\n\nPROJECTS := <%= table.concat(_MAKE.esc(table.extract(this.projects, \"name\")), \" \") %>\n\n.PHONY: all clean $(PROJECTS)\n\nall: $(PROJECTS)\n\n<% for _,prj in ipairs(this.projects) do %>\n <% for cfg in premake.eachconfig(prj) do %>\nifeq ($(config),<%= _MAKE.esc(cfg.name:lower())%>)\n  DEPENDENCIES := <%= table.concat(_MAKE.esc(table.extract(premake.getdependencies(cfg), \"name\")), \" \") %>\nendif\n <% end %>\n\n<%= _MAKE.esc(prj.name) %>: ${DEPENDENCIES}\n	@echo ==== Building <%= prj.name %> ====\n	@${MAKE} --no-print-directory -C <%=_MAKE.esc(path.getrelative(this.location, prj.location))%> -f <%=_MAKE.esc(_MAKE.getmakefilename(prj, true))%>\n	\n<% end %>\n\nclean:\n<% for _,prj in ipairs(this.projects) do %>\n	@${MAKE} --no-print-directory -C <%=_MAKE.esc(path.getrelative(this.location, prj.location))%> -f <%=_MAKE.esc(_MAKE.getmakefilename(prj, true))%> clean\n<% end %>\n]])",
	"_TEMPLATES.make_cpp=premake.loadtemplatestring('make_cpp',[[<% local cc = premake[_OPTIONS.cc] %>\n# <%= premake.actions[_ACTION].shortname %> project makefile autogenerated by Premake\n\nifndef config\n  config=<%= _MAKE.esc(this.configurations[1]:lower()) %>\nendif\n\nifndef verbose\n  SILENT = @\nendif\n\n\n<% for cfg in premake.eachconfig(this) do %>\nifeq ($(config),<%= _MAKE.esc(cfg.name:lower())%>)\n  TARGETDIR  = <%= _MAKE.esc(cfg.buildtarget.directory) %>\n  TARGET     = $(TARGETDIR)/<%= _MAKE.esc(cfg.buildtarget.name) %>\n  OBJDIR     = <%= _MAKE.esc(cfg.objectsdir) %>\n  DEFINES   += <%= table.concat(cc.getdefines(cfg.defines), \" \") %>\n  INCLUDES  += <%= table.concat(cc.getincludedirs(cfg.includedirs), \" \") %>\n  CPPFLAGS  += <%= cc.getcppflags(cfg) %> $(DEFINES) $(INCLUDES)\n  CFLAGS    += $(CPPFLAGS) $(ARCH) <%= table.concat(table.join(cc.getcflags(cfg), cfg.buildoptions), \" \") %>\n  CXXFLAGS  += $(CFLAGS) <%= table.concat(cc.getcxxflags(cfg), \" \") %>\n  LDFLAGS   += <%= table.concat(table.join(cc.getldflags(cfg), cc.getlinkflags(cfg), cfg.linkoptions), \" \") %>\n  RESFLAGS  += $(DEFINES) $(INCLUDES) <%= table.concat(table.join(cc.getdefines(cfg.resdefines), cc.getincludedirs(cfg.resincludedirs), cfg.resoptions), \" \") %>\n  LDDEPS    += <%= table.concat(_MAKE.esc(premake.getlinks(cfg, \"siblings\", \"fullpath\")), \" \") %>\n  <% if cfg.kind == \"StaticLib\" then %>\n  LINKCMD    = ar -rcs $(TARGET) $(OBJECTS)\n  <% else %>\n  LINKCMD    = $(<%= iif(cfg.language == \"C\", \"CC\", \"CXX\") %>) -o $(TARGET) $(OBJECTS) $(LDFLAGS) $(RESOURCES) $(ARCH)\n  <% end %>\n  define PREBUILDCMDS\n    <% if #cfg.prebuildcommands > 0 then %>\n	@echo Running pre-build commands\n	<%= table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\") %>\n    <% end %>\n  endef\n  define PRELINKCMDS\n    <% if #cfg.prelinkcommands > 0 then %>\n	@echo Running pre-link commands\n	<%= table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\") %>\n    <% end %>\n  endef\n  define POSTBUILDCMDS\n    <% if #cfg.postbuildcommands > 0 then %>\n	@echo Running post-build commands\n	<%= table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\") %>\n    <% end %>\n  endef\nendif\n\n<% end %>\n\nOBJECTS := \\\n<% for _, file in ipairs(this.files) do %>\n <% if path.iscppfile(file) then %>\n	$(OBJDIR)/<%= _MAKE.esc(path.getbasename(file)) %>.o \\\n <% end %>\n<% end %>\n\nRESOURCES := \\\n<% for _, file in ipairs(this.files) do %>\n <% if path.isresourcefile(file) then %>\n	$(OBJDIR)/<%= _MAKE.esc(path.getbasename(file)) %>.res \\\n <% end %>\n<% end %>\n\nSHELLTYPE := msdos\nifeq (,$(ComSpec)$(COMSPEC))\n  SHELLTYPE := posix\nendif\nifeq (/bin,$(findstring /bin,$(SHELL)))\n  SHELLTYPE := posix\nendif\n\nifeq (posix,$(SHELLTYPE))\n   define MKDIR_RULE\n	@echo Creating $@\n	$(SILENT) mkdir -p $@\n   endef\nelse\n   define MKDIR_RULE\n	@echo Creating $@\n	$(SILENT) mkdir $(subst /,\\\\,$@)\n   endef\nendif\n\n\n.PHONY: clean prebuild prelink\n\n<% if os.is(\"MacOSX\") and this.kind == \"WindowedApp\" then %>\nall: $(TARGETDIR) $(OBJDIR) prebuild $(OBJECTS) $(RESOURCES) prelink $(TARGET) $(dir $(TARGETDIR))PkgInfo $(dir $(TARGETDIR))Info.plist\n<% else %>\nall: $(TARGETDIR) $(OBJDIR) prebuild $(OBJECTS) $(RESOURCES) prelink $(TARGET)\n<% end %>\n\n$(TARGET): $(OBJECTS) $(LDDEPS) $(RESOURCES)\n	@echo Linking <%= this.name %>\n	@$(LINKCMD)\n	$(POSTBUILDCMDS)\n\n$(TARGETDIR):\n	$(MKDIR_RULE)\n	\n$(OBJDIR):\n	$(MKDIR_RULE)\n\n<% if os.is(\"MacOSX\") and this.kind == \"WindowedApp\" then %>\n$(dir $(TARGETDIR))PkgInfo:\n\n$(dir $(TARGETDIR))Info.plist:\n<% end %>\n\nclean:\n	@echo Cleaning <%= this.name %>\nifeq (posix,$(SHELLTYPE))\n	$(SILENT) rm -f  $(TARGET)\n	$(SILENT) rm -rf $(OBJDIR)\nelse\n	$(SILENT) if exist $(subst /,\\\\,$(TARGET)) del $(subst /,\\\\,$(TARGET))\n	$(SILENT) if exist $(subst /,\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\,$(OBJDIR))\nendif\n\nprebuild:\n	$(PREBUILDCMDS)\n	\nprelink:\n	$(PRELINKCMDS)\n	\n<% for _, file in ipairs(this.files) do %>\n<% if path.iscppfile(file) then %>\n$(OBJDIR)/<%= _MAKE.esc(path.getbasename(file)) %>.o: <%= _MAKE.esc(file) %>\n	@echo $(notdir $<)\n	<% if (path.iscfile(file)) then %>\n	$(SILENT) $(CC) $(CFLAGS) -o $@ -c $<\n	<% else %>\n	$(SILENT) $(CXX) $(CXXFLAGS) -o $@ -c $<\n	<% end %>\n	\n<% elseif (path.getextension(file) == \".rc\") then %>\n$(OBJDIR)/<%= _MAKE.esc(path.getbasename(file)) %>.res: <%= _MAKE.esc(file) %>\n	@echo $(notdir $<)\n	$(SILENT) windres $< -O coff -o $@ $(RESFLAGS)\n\n<% end %>\n<% end %>\n\n-include $(OBJECTS:%.o=%.d)\n]])",
	"_TEMPLATES.make_csharp=premake.loadtemplatestring('make_csharp',[[<% \n	local csc = premake.csc\n	\n	--\n	-- Given a .resx resource file, builds the path to corresponding .resource\n	-- file, matching the behavior and naming of Visual Studio.\n	--\n		\n	function getresourcefilename(cfg, fname)\n		if path.getextension(fname) == \".resx\" then\n		    local name = cfg.buildtarget.basename .. \".\"\n		    local dir = path.getdirectory(fname)\n		    if dir ~= \".\" then \n				name = name .. path.translate(dir, \".\") .. \".\"\n			end\n			return \"$(OBJDIR)/\" .. name .. path.getbasename(fname) .. \".resources\"\n		else\n			return fname\n		end\n	end\n\n	\n	-- Do some processing up front: build a list of configuration-dependent libraries.\n	-- Libraries that are built to a location other than $(TARGETDIR) will need to\n	-- be copied so they can be found at runtime.\n	local cfglibs = { }\n	local cfgpairs = { }\n	local anycfg\n	for cfg in premake.eachconfig(this) do\n		anycfg = cfg\n		cfglibs[cfg] = premake.getlinks(cfg, \"siblings\", \"fullpath\")\n		cfgpairs[cfg] = { }\n		for _, fname in ipairs(cfglibs[cfg]) do\n			if path.getdirectory(fname) ~= cfg.buildtarget.directory then\n				cfgpairs[cfg][\"$(TARGETDIR)/\"..path.getname(fname)] = fname\n			end\n		end\n	end\n	\n	-- sort the files into categories, based on their build action\n	local sources = {}\n	local embedded = { }\n	local copypairs = { }\n	\n	for fcfg in premake.eachfile(this) do\n		local action = csc.getbuildaction(fcfg)\n		if action == \"Compile\" then\n			table.insert(sources, fcfg.name)\n		elseif action == \"EmbeddedResource\" then			\n			table.insert(embedded, fcfg.name)\n		elseif action == \"Content\" then\n			copypairs[\"$(TARGETDIR)/\"..path.getname(fcfg.name)] = fcfg.name\n		elseif path.getname(fcfg.name):lower() == \"app.config\" then\n			copypairs[\"$(TARGET).config\"] = fcfg.name	\n		end\n	end\n\n	-- Any assemblies that are on the library search paths should be copied\n	-- to $(TARGETDIR) so they can be found at runtime\n	local paths = table.translate(this.libdirs, function(v) return path.join(this.basedir, v) end)\n	paths = table.join({this.basedir}, paths)\n	for _, libname in ipairs(premake.getlinks(this, \"system\", \"fullpath\")) do\n		local libdir = os.pathsearch(libname..\".dll\", unpack(paths))\n		if (libdir) then\n			local target = \"$(TARGETDIR)/\"..path.getname(libname)\n			local source = path.getrelative(this.basedir, path.join(libdir, libname))..\".dll\"\n			copypairs[target] = source\n		end\n	end\n	\n	-- end of preprocessing --\n	\n%>\n# <%= premake.actions[_ACTION].shortname %> project makefile autogenerated by Premake\n\nifndef config\n  config=<%= _MAKE.esc(this.configurations[1]:lower()) %>\nendif\n\nifndef verbose\n  SILENT = @\nendif\n\nifndef CSC\n  CSC=<%= csc.getcompilervar(this) %>\nendif\n\nifndef RESGEN\n  RESGEN=resgen\nendif\n\n\n<% for cfg in premake.eachconfig(this) do %>\nifeq ($(config),<%= _MAKE.esc(cfg.name:lower())%>)\n  TARGETDIR  := <%= _MAKE.esc(cfg.buildtarget.directory) %>\n  OBJDIR     := <%= _MAKE.esc(cfg.objectsdir) %>\n  DEPENDS    := <%= table.concat(_MAKE.esc(premake.getlinks(cfg, \"dependencies\", \"fullpath\")), \" \") %>\n  REFERENCES := <%= table.implode(_MAKE.esc(cfglibs[cfg]), \"/r:\", \"\", \" \") %>\n  FLAGS      += <%= table.concat(csc.getflags(cfg), \" \") %> <%= table.implode(cfg.defines, \"/d:\", \"\", \" \") %>\n  define PREBUILDCMDS\n    <% if #cfg.prebuildcommands > 0 then %>\n	@echo Running pre-build commands\n	<%= table.implode(cfg.prebuildcommands, \"\", \"\", \"\\n\\t\") %>\n    <% end %>\n  endef\n  define PRELINKCMDS\n    <% if #cfg.prelinkcommands > 0 then %>\n	@echo Running pre-link commands\n	<%= table.implode(cfg.prelinkcommands, \"\", \"\", \"\\n\\t\") %>\n    <% end %>\n  endef\n  define POSTBUILDCMDS\n    <% if #cfg.postbuildcommands > 0 then %>\n	@echo Running post-build commands\n	<%= table.implode(cfg.postbuildcommands, \"\", \"\", \"\\n\\t\") %>\n    <% end %>\n  endef\nendif\n<%	end %>\n\n# To maintain compatibility with VS.NET, these values must be set at the project level\nTARGET      = $(TARGETDIR)/<%= _MAKE.esc(this.buildtarget.name) %>\nFLAGS      += /t:<%= csc.getkind(this):lower() %> <%= table.implode(_MAKE.esc(this.libdirs), \"/lib:\", \"\", \" \") %>\nREFERENCES += <%= table.implode(_MAKE.esc(premake.getlinks(this, \"system\", \"basename\")), \"/r:\", \".dll\", \" \") %>\n\n\nSOURCES := \\\n<% for _, fname in ipairs(sources) do %>\n	<%= _MAKE.esc(path.translate(fname)) %> \\\n<% end %>\n\nEMBEDFILES := \\\n<% for _, fname in ipairs(embedded) do %>\n	<%= _MAKE.esc(getresourcefilename(this, fname)) %> \\\n<% end %>\n\nCOPYFILES += \\\n<% for target, source in pairs(cfgpairs[anycfg]) do %>\n	<%= _MAKE.esc(target) %> \\\n<% end %>\n<% for target, source in pairs(copypairs) do %>\n	<%= _MAKE.esc(target) %> \\\n<% end %>\n\n\nSHELLTYPE := msdos\nifeq (,$(ComSpec)$(COMSPEC))\n  SHELLTYPE := posix\nendif\nifeq (/bin,$(findstring /bin,$(SHELL)))\n  SHELLTYPE := posix\nendif\n\nifeq (posix,$(SHELLTYPE))\n  define MKDIR_RULE\n	@echo Creating $@\n	$(SILENT) mkdir -p $@\n  endef\n  define COPY_RULE\n	@echo Copying $(notdir $@)\n	$(SILENT) cp -fR $^ $@\n  endef	\nelse\n  define MKDIR_RULE\n	@echo Creating $@\n	$(SILENT) mkdir $(subst /,\\\\,$@)\n  endef\n  define COPY_RULE\n	@echo Copying $(notdir $@)\n	$(SILENT) copy /Y $(subst /,\\\\,$^) $(subst /,\\\\,$@)\n  endef	\nendif\n\n\n.PHONY: clean prebuild prelink\n\nall: $(TARGETDIR) $(OBJDIR) prebuild $(EMBEDFILES) $(COPYFILES) prelink $(TARGET)\n\n$(TARGET): $(SOURCES) $(EMBEDFILES) $(DEPENDS)\n	$(SILENT) $(CSC) /nologo /out:$@ $(FLAGS) $(REFERENCES) $(SOURCES) $(patsubst %,/resource:%,$(EMBEDFILES))\n	$(POSTBUILDCMDS)\n\n$(TARGETDIR):\n	$(MKDIR_RULE)\n	\n$(OBJDIR):\n	$(MKDIR_RULE)\n\nclean:\n	@echo Cleaning <%= this.name %>\nifeq (posix,$(SHELLTYPE))\n	$(SILENT) rm -f $(TARGETDIR)/<%= this.buildtarget.basename %>.* $(COPYFILES)\n	$(SILENT) rm -rf $(OBJDIR)\nelse\n	$(SILENT) if exist $(subst /,\\\\,$(TARGETDIR)/<%= this.buildtarget.basename %>.*) del $(subst /,\\\\,$(TARGETDIR)/<%= this.buildtarget.basename %>.*)\n	<% for target, source in pairs(cfgpairs[anycfg]) do %>\n	$(SILENT) if exist $(subst /,\\\\,<%= target %>) del $(subst /,\\\\,<%= target %>)\n	<% end %>\n	<% for target, source in pairs(copypairs) do %>\n	$(SILENT) if exist $(subst /,\\\\,<%= target %>) del $(subst /,\\\\,<%= target %>)\n	<% end %>\n	$(SILENT) if exist $(subst /,\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\,$(OBJDIR))\nendif\n\nprebuild:\n	$(PREBUILDCMDS)\n	\nprelink:\n	$(PRELINKCMDS)\n\n\n# Per-configuration copied file rules \n<% for cfg in premake.eachconfig(this) do %>	\nifeq ($(config),<%= _MAKE.esc(cfg.name:lower())%>)\n<% for target, source in pairs(cfgpairs[cfg]) do %>\n<%= _MAKE.esc(target) %>: <%= _MAKE.esc(source) %>\n	$(COPY_RULE)\n<% end %>\nendif\n<% end %>\n\n# Copied file rules\n<% for target, source in pairs(copypairs) do %>\n<%= _MAKE.esc(target) %>: <%= _MAKE.esc(source) %>\n	$(COPY_RULE)\n<% end %>\n	\n# Embedded file rules\n<% for _, fname in ipairs(embedded) do if path.getextension(fname) == \".resx\" then %>\n<%= _MAKE.esc(getresourcefilename(this, fname)) %>: <%= _MAKE.esc(fname) %>\n	$(SILENT) $(RESGEN) $^ $@\n<% end end %>\n]])",
	"_TEMPLATES.vs2002_solution=premake.loadtemplatestring('vs2002_solution',[[<% eol = \"\\r\\n\" %>\nMicrosoft Visual Studio Solution File, Format Version 7.00\n<% for prj in premake.eachproject(this) do %>\nProject(\"{<%=_VS.tool(prj)%>}\") = \"<%=prj.name%>\", \"<%=path.translate(path.getrelative(this.location, _VS.projectfile(prj)))%>\", \"{<%=prj.uuid%>}\"\nEndProject\n<% end %>\nGlobal\n	GlobalSection(SolutionConfiguration) = preSolution\n	<% for i,cfgname in ipairs(this.configurations) do %>\n		ConfigName.<%= i-1 %> = <%= cfgname %>\n	<% end %>		\n	EndGlobalSection\n	GlobalSection(ProjectDependencies) = postSolution\n	<% for prj in premake.eachproject(this) do %>\n	 <% for i,dep in ipairs(premake.getdependencies(prj)) do %>\n		{<%= prj.uuid %>}.<%= i - 1 %> = {<%= dep.uuid %>}\n	 <% end %>\n	<% end %>\n	EndGlobalSection\n	GlobalSection(ProjectDependencies) = postSolution\n	EndGlobalSection\n	GlobalSection(ProjectConfiguration) = postSolution\n	<% for prj in premake.eachproject(this) do %>\n	 <% for i,cfgname in ipairs(this.configurations) do %>\n		{<%=prj.uuid%>}.<%=cfgname%>.ActiveCfg = <%=cfgname%>|<%=_VS.arch(prj)%>\n		{<%=prj.uuid%>}.<%=cfgname%>.Build.0 = <%=cfgname%>|<%=_VS.arch(prj)%>\n	 <% end %>\n	<% end %>\n	EndGlobalSection\n	GlobalSection(ExtensibilityGlobals) = postSolution\n	EndGlobalSection\n	GlobalSection(ExtensibilityAddIns) = postSolution\n	EndGlobalSection\nEndGlobal\n]])",
	"_TEMPLATES.vs2002_csproj=premake.loadtemplatestring('vs2002_csproj',[[<% \n	eol = \"\\r\\n\" \n	local csc = premake.csc\n\n	--\n	-- Figure out what elements a particular file need in its item block,\n	-- based on its build action and any related files in the project.\n	-- \n	\n	function getelements(prj, action, fname)\n	\n		if action == \"Compile\" and fname:endswith(\".cs\") then\n			return \"SubTypeCode\"\n		end\n\n		if action == \"EmbeddedResource\" and fname:endswith(\".resx\") then\n			-- is there a matching *.cs file?\n			local basename = fname:sub(1, -6)\n			local testname = path.getname(basename .. \".cs\")\n			if premake.findfile(prj, testname) then\n				return \"Dependency\", testname\n			end\n		end\n		\n		return \"None\"\n	end\n\n	-- end of preprocessing; template starts here --	\n%>\n<VisualStudioProject>\n	<CSHARP\n		ProjectType = \"Local\"\n		ProductVersion = \"<%= iif(_ACTION == \"vs2002\", \"7.0.9254\", \"7.10.3077\") %>\"\n		SchemaVersion = \"<%= iif(_ACTION == \"vs2002\", \"1.0\", \"2.0\") %>\"\n		ProjectGuid = \"{<%= this.uuid %>}\"\n	>\n		<Build>\n			<Settings\n				ApplicationIcon = \"\"\n				AssemblyKeyContainerName = \"\"\n				AssemblyName = \"<%= this.buildtarget.basename %>\"\n				AssemblyOriginatorKeyFile = \"\"\n				DefaultClientScript = \"JScript\"\n				DefaultHTMLPageLayout = \"Grid\"\n				DefaultTargetSchema = \"IE50\"\n				DelaySign = \"false\"\n				<% if _ACTION == \"vs2002\" then %>\n				NoStandardLibraries = \"false\"\n				<% end %>\n				OutputType = \"<%= csc.getkind(this) %>\"\n				<% if _ACTION == \"vs2003\" then %>\n				PreBuildEvent = \"\"\n				PostBuildEvent = \"\"\n				<% end %>\n				RootNamespace = \"<%= this.buildtarget.basename %>\"\n				<% if _ACTION == \"vs2003\" then %>\n				RunPostBuildEvent = \"OnBuildSuccess\"\n				<% end %>\n				StartupObject = \"\"\n			>\n			<% for cfg in premake.eachconfig(this) do %>\n				<Config\n					Name = \"<%= premake.esc(cfg.name) %>\"\n					AllowUnsafeBlocks = \"<%= iif(cfg.flags.Unsafe, \"true\", \"false\") %>\"\n					BaseAddress = \"285212672\"\n					CheckForOverflowUnderflow = \"false\"\n					ConfigurationOverrideFile = \"\"\n					DefineConstants = \"<%= premake.esc(table.concat(cfg.defines, \";\")) %>\"\n					DocumentationFile = \"\"\n					DebugSymbols = \"<%= iif(cfg.flags.Symbols, \"true\", \"false\") %>\"\n					FileAlignment = \"4096\"\n					IncrementalBuild = \"false\"\n					<% if _ACTION == \"vs2003\" then %>\n					NoStdLib = \"false\"\n					NoWarn = \"\"\n					<% end %>\n					Optimize = \"<%= iif(cfg.flags.Optimize or cfg.flags.OptimizeSize or cfg.flags.OptimizeSpeed, \"true\", \"false\") %>\"\n					OutputPath = \"<%= premake.esc(cfg.buildtarget.directory) %>\"\n					RegisterForComInterop = \"false\"\n					RemoveIntegerChecks = \"false\"\n					TreatWarningsAsErrors = \"<%= iif(cfg.flags.FatalWarnings, \"true\", \"false\") %>\"\n					WarningLevel = \"4\"\n				/>\n			<% end %>\n			</Settings>\n			<References>\n			<% for _, prj in ipairs(premake.getlinks(this, \"siblings\", \"object\")) do %>\n				<Reference\n					Name = \"<%= prj.buildtarget.basename %>\"\n					Project = \"{<%= prj.uuid %>}\"\n					Package = \"{<%= _VS.tool(prj) %>}\"\n				/>\n			<% end %>\n			<% for _, linkname in ipairs(premake.getlinks(this, \"system\", \"fullpath\")) do %>\n				<Reference\n					Name = \"<%= path.getbasename(linkname) %>\"\n					AssemblyName = \"<%= path.getname(linkname) %>\"\n					<% if path.getdirectory(linkname) ~= \".\" then %>\n					HintPath = \"<%= path.translate(linkname, \"\\\\\") %>\"\n					<% end %>\n				/>\n			<% end %>\n			</References>\n		</Build>\n		<Files>\n			<Include>\n			<%\n			for fcfg in premake.eachfile(this) do\n			  local action = csc.getbuildaction(fcfg)\n			  local fname  = path.translate(premake.esc(fcfg.name), \"\\\\\")\n			  local elements, dependency = getelements(this, action, fcfg.name)\n			%>\n				<File\n					RelPath = \"<%= premake.esc(fname) %>\"\n					BuildAction = \"<%= action %>\"\n					<% if dependency then %>\n					DependentUpon = \"<%= premake.esc(path.translate(dependency, \"\\\\\")) %>\"\n					<% end %>\n					<% if elements == \"SubTypeCode\" then %>\n					SubType = \"Code\"\n					<% end %>\n				/>					\n			<% end %>\n			</Include>\n		</Files>\n	</CSHARP>\n</VisualStudioProject>\n]])",
	"_TEMPLATES.vs2002_csproj_user=premake.loadtemplatestring('vs2002_csproj_user',[[<% \n	eol = \"\\r\\n\" \n	local csc = premake.csc\n%>	\n<VisualStudioProject>\n	<CSHARP>\n		<Build>\n			<Settings ReferencePath = \"<%= table.concat(table.translate(this.libdirs, function(v) return path.translate(path.getabsolute(this.location..\"/\"..v),\"\\\\\") end), \";\") %>\">\n			<% for cfg in premake.eachconfig(this) do %>\n				<Config\n					Name = \"<%= premake.esc(cfg.name) %>\"\n					EnableASPDebugging = \"false\"\n					EnableASPXDebugging = \"false\"\n					EnableUnmanagedDebugging = \"false\"\n					EnableSQLServerDebugging = \"false\"\n					RemoteDebugEnabled = \"false\"\n					RemoteDebugMachine = \"\"\n					StartAction = \"Project\"\n					StartArguments = \"\"\n					StartPage = \"\"\n					StartProgram = \"\"\n					StartURL = \"\"\n					StartWorkingDirectory = \"\"\n					StartWithIE = \"false\"\n				/>\n			<% end %>\n			</Settings>\n		</Build>\n		<OtherProjectSettings\n			CopyProjectDestinationFolder = \"\"\n			CopyProjectUncPath = \"\"\n			CopyProjectOption = \"0\"\n			ProjectView = \"ProjectFiles\"\n			ProjectTrust = \"0\"\n		/>\n	</CSHARP>\n</VisualStudioProject>\n]])",
	"_TEMPLATES.vs2003_solution=premake.loadtemplatestring('vs2003_solution',[[<% eol = \"\\r\\n\" %>\nMicrosoft Visual Studio Solution File, Format Version 8.00\n<% for prj in premake.eachproject(this) do %>\nProject(\"{<%=_VS.tool(prj)%>}\") = \"<%=prj.name%>\", \"<%=path.translate(path.getrelative(this.location, _VS.projectfile(prj)))%>\", \"{<%=prj.uuid%>}\"\n  <% local deps = premake.getdependencies(prj); if #deps > 0 then %>\n	ProjectSection(ProjectDependencies) = postProject\n	<% for _,dep in ipairs(deps) do %>\n		{<%= dep.uuid %>} = {<%= dep.uuid %>}\n	<% end %>\n	EndProjectSection\n  <% end %>\nEndProject\n<% end %>\nGlobal\n	GlobalSection(SolutionConfiguration) = preSolution\n	<% for i,cfgname in ipairs(this.configurations) do %>\n		<%= cfgname %> = <%= cfgname %>\n	<% end %>		\n	EndGlobalSection\n	GlobalSection(ProjectDependencies) = postSolution\n	EndGlobalSection\n	GlobalSection(ProjectConfiguration) = postSolution\n	<% for prj in premake.eachproject(this) do %>\n	 <% for i,cfgname in ipairs(this.configurations) do %>\n		{<%=prj.uuid%>}.<%=cfgname%>.ActiveCfg = <%=cfgname%>|<%=_VS.arch(prj)%>\n		{<%=prj.uuid%>}.<%=cfgname%>.Build.0 = <%=cfgname%>|<%=_VS.arch(prj)%>\n	 <% end %>\n	<% end %>\n	EndGlobalSection\n	GlobalSection(ExtensibilityGlobals) = postSolution\n	EndGlobalSection\n	GlobalSection(ExtensibilityAddIns) = postSolution\n	EndGlobalSection\nEndGlobal\n]])",
	"_TEMPLATES.vs2005_solution=premake.loadtemplatestring('vs2005_solution',[[<% eol = \"\\r\\n\" %>\n<%= \"\\239\\187\\191\" %>\n<% local hascpp, hasdotnet %>\n<% if _ACTION == \"vs2005\" then %>\nMicrosoft Visual Studio Solution File, Format Version 9.00\n# Visual Studio 2005\n<% elseif _ACTION == \"vs2008\" then %>\nMicrosoft Visual Studio Solution File, Format Version 10.00\n# Visual Studio 2008\n<% end %>\n<% for prj in premake.eachproject(this) do %>\n  <% if (prj.language == \"C\" or prj.language == \"C++\") then hascpp = true end %>\n  <% if (prj.language == \"C#\") then hasdotnet = true end %>\nProject(\"{<%=_VS.tool(prj)%>}\") = \"<%=prj.name%>\", \"<%=path.translate(path.getrelative(this.location, _VS.projectfile(prj)),\"\\\\\")%>\", \"{<%=prj.uuid%>}\"\n  <% local deps = premake.getdependencies(prj); if #deps > 0 then %>\n	ProjectSection(ProjectDependencies) = postProject\n	<% for _,dep in ipairs(deps) do %>\n		{<%= dep.uuid %>} = {<%= dep.uuid %>}\n	<% end %>\n	EndProjectSection\n  <% end %>\nEndProject\n<% end %>\nGlobal\n	GlobalSection(SolutionConfigurationPlatforms) = preSolution\n    <% for _, cfgname in ipairs(this.configurations) do %>\n     <% if hasdotnet then %>\n		<%= cfgname %>|Any CPU = <%= cfgname %>|Any CPU\n     <% end; if hasdotnet and hascpp then %>\n		<%= cfgname %>|Mixed Platforms = <%= cfgname %>|Mixed Platforms\n     <% end; if hascpp then %>\n		<%= cfgname %>|Win32 = <%= cfgname %>|Win32\n     <% end %>\n    <% end %>\n	EndGlobalSection\n	GlobalSection(ProjectConfigurationPlatforms) = postSolution\n	<% for prj in premake.eachproject(this) do %>\n	 <% for _, cfgname in ipairs(this.configurations) do %>\n	  <% if hasdotnet then %>\n		{<%= prj.uuid %>}.<%= cfgname %>|Any CPU.ActiveCfg = <%= cfgname %>|<%= _VS.arch(prj) %>\n	   <% if (prj.language ~= \"C\" and prj.language ~= \"C++\") then %>\n		{<%= prj.uuid %>}.<%= cfgname %>|Any CPU.Build.0 = <%= cfgname %>|<%= _VS.arch(prj) %>\n	   <% end %>\n	  <% end; if (hasdotnet and hascpp) then %>\n		{<%= prj.uuid %>}.<%= cfgname %>|Mixed Platforms.ActiveCfg = <%= cfgname %>|<%= _VS.arch(prj) %>\n		{<%= prj.uuid %>}.<%= cfgname %>|Mixed Platforms.Build.0 = <%= cfgname %>|<%= _VS.arch(prj) %>\n	  <% end; if (hascpp) then %>\n		{<%= prj.uuid %>}.<%= cfgname %>|Win32.ActiveCfg = <%= cfgname %>|<%= _VS.arch(prj) %>\n	   <% if (prj.language == \"C\" or prj.language == \"C++\") then %>\n		{<%= prj.uuid %>}.<%= cfgname %>|Win32.Build.0 = <%= cfgname %>|<%= _VS.arch(prj) %>\n	   <% end %>\n	  <% end %>\n	 <% end %>\n	<% end %>\n	EndGlobalSection\n	GlobalSection(SolutionProperties) = preSolution\n		HideSolutionNode = FALSE\n	EndGlobalSection\nEndGlobal\n]])",
	"_TEMPLATES.vs2005_csproj=premake.loadtemplatestring('vs2005_csproj',[[<% \n	eol = \"\\r\\n\" \n	local csc = premake.csc\n\n	-- translate the action to format and tool versions\n	local vsversion, toolversion\n	if _ACTION == \"vs2005\" then\n		vsversion   = \"8.0.50727\"\n		toolversion = nil\n	elseif _ACTION == \"vs2008\" then\n		vsversion   = \"9.0.50727\"\n		toolversion = \"3.5\"\n	end\n	\n	--\n	-- Figure out what elements a particular source code file need in its item\n	-- block, based on its build action and any related files in the project.\n	-- \n	\n	function getelements(prj, action, fname)\n	\n		if action == \"Compile\" and fname:endswith(\".cs\") then\n			if fname:endswith(\".Designer.cs\") then\n				-- is there a matching *.cs file?\n				local basename = fname:sub(1, -13)\n				local testname = basename .. \".cs\"\n				if premake.findfile(prj, testname) then\n					return \"Dependency\", testname\n				end\n				-- is there a matching *.resx file?\n				testname = basename .. \".resx\"\n				if premake.findfile(prj, testname) then\n					return \"AutoGen\", testname\n				end\n			else\n				-- is there a *.Designer.cs file?\n				local basename = fname:sub(1, -4)\n				local testname = basename .. \".Designer.cs\"\n				if premake.findfile(prj, testname) then\n					return \"SubTypeForm\"\n				end\n			end\n		end\n\n		if action == \"EmbeddedResource\" and fname:endswith(\".resx\") then\n			-- is there a matching *.cs file?\n			local basename = fname:sub(1, -6)\n			local testname = path.getname(basename .. \".cs\")\n			if premake.findfile(prj, testname) then\n				if premake.findfile(prj, basename .. \".Designer.cs\") then\n					return \"DesignerType\", testname\n				else\n					return \"Dependency\", testname\n				end\n			else\n				-- is there a matching *.Designer.cs?\n				testname = path.getname(basename .. \".Designer.cs\")\n				if premake.findfile(prj, testname) then\n					return \"AutoGenerated\"\n				end\n			end\n		end\n				\n		if action == \"Content\" then\n			return \"CopyNewest\"\n		end\n		\n		return \"None\"\n	end\n\n	-- end of preprocessing; template starts here --	\n%>\n<% if toolversion then %>\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" ToolsVersion=\"<%= toolversion %>\">\n<% else %>\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n<% end %>\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \"><%= premake.esc(this.solution.configurations[1]) %></Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProductVersion><%= vsversion %></ProductVersion>\n    <SchemaVersion>2.0</SchemaVersion>\n    <ProjectGuid>{<%= this.uuid %>}</ProjectGuid>\n    <OutputType><%= csc.getkind(this) %></OutputType>\n    <AppDesignerFolder>Properties</AppDesignerFolder>\n    <RootNamespace><%= this.buildtarget.basename %></RootNamespace>\n    <AssemblyName><%= this.buildtarget.basename %></AssemblyName>\n  </PropertyGroup>\n  <% for cfg in premake.eachconfig(this) do %>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == '<%= premake.esc(cfg.name) %>|AnyCPU' \">\n    <% if cfg.flags.Symbols then %>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <% else %>\n    <DebugType>pdbonly</DebugType>\n    <% end %>\n    <Optimize><%= iif(cfg.flags.Optimize or cfg.flags.OptimizeSize or cfg.flags.OptimizeSpeed, \"true\", \"false\") %></Optimize>\n    <OutputPath><%= cfg.buildtarget.directory %></OutputPath>\n    <DefineConstants><%= table.concat(premake.esc(cfg.defines), \";\") %></DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <% if cfg.flags.Unsafe then %>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n    <% end %>\n    <% if cfg.flags.FatalWarnings then %>\n    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>\n    <% end %>\n  </PropertyGroup>\n  <% end %>\n  <ItemGroup>\n    <% for _, prj in ipairs(premake.getlinks(this, \"siblings\", \"object\")) do %>\n    <ProjectReference Include=\"<%= path.translate(path.getrelative(this.location, _VS.projectfile(prj)), \"\\\\\") %>\">\n      <Project>{<%= prj.uuid %>}</Project>\n      <Name><%= premake.esc(prj.name) %></Name>\n    </ProjectReference>\n    <% end %>\n    <% for _, linkname in ipairs(premake.getlinks(this, \"system\", \"basename\")) do %>\n    <Reference Include=\"<%= premake.esc(linkname) %>\" />\n    <% end %>\n  </ItemGroup>\n  <ItemGroup>\n  <%\n    for fcfg in premake.eachfile(this) do\n      local action = csc.getbuildaction(fcfg)\n      local fname  = path.translate(premake.esc(fcfg.name), \"\\\\\")\n      local elements, dependency = getelements(this, action, fcfg.name)\n      if elements == \"None\" then\n    %>\n    <<%= action %> Include=\"<%= fname %>\" />\n    <% \n      else \n    %>\n    <<%= action %> Include=\"<%= fname %>\">\n      <% if elements == \"AutoGen\" then %>\n      <AutoGen>True</AutoGen>\n      <% elseif elements == \"AutoGenerated\" then %>\n      <SubType>Designer</SubType>\n      <Generator>ResXFileCodeGenerator</Generator>\n      <LastGenOutput><%= premake.esc(path.getbasename(fcfg.name)) %>.Designer.cs</LastGenOutput>\n      <% elseif elements == \"SubTypeDesigner\" then %>\n      <SubType>Designer</SubType>\n      <% elseif elements == \"SubTypeForm\" then %>\n      <SubType>Form</SubType>\n      <% elseif elements == \"PreserveNewest\" then %>\n      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n      <% end %>\n      <% if dependency then %>      \n      <DependentUpon><%= path.translate(premake.esc(dependency), \"\\\\\") %></DependentUpon>\n      <% end %>\n    </<%= action %>>\n    <% \n      end \n    end\n  %>\n  </ItemGroup>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CSharp.targets\" />\n  <!-- To modify your build process, add your task inside one of the targets below and uncomment it.\n       Other similar extension points exist, see Microsoft.Common.targets.\n  <Target Name=\"BeforeBuild\">\n  </Target>\n  <Target Name=\"AfterBuild\">\n  </Target>\n  -->\n</Project>\n]])",
	"_TEMPLATES.vs2005_csproj_user=premake.loadtemplatestring('vs2005_csproj_user',[[<% eol = \"\\r\\n\" %>\n<Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <ReferencePath><%= table.concat(table.translate(this.libdirs, function(v) return path.translate(path.getabsolute(this.location..\"/\"..v),\"\\\\\") end), \";\") %></ReferencePath>\n  </PropertyGroup>\n</Project>        ]])",
	"_TEMPLATES.vs200x_vcproj=premake.loadtemplatestring('vs200x_vcproj',[[<% eol = \"\\r\\n\" %>\n<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\n<VisualStudioProject\n	ProjectType=\"Visual C++\"\n<% if _ACTION == \"vs2002\" then %>\n	Version=\"7.00\"\n<% elseif _ACTION == \"vs2003\" then %>\n	Version=\"7.10\"\n<% elseif _ACTION == \"vs2005\" then %>\n	Version=\"8.00\"\n<% elseif _ACTION == \"vs2008\" then %>\n	Version=\"9.00\"\n<% end %>\n	Name=\"<%= premake.esc(this.name) %>\"\n	ProjectGUID=\"{<%= this.uuid %>}\"\n<% if _ACTION > \"vs2003\" then %>\n	RootNamespace=\"<%= this.name %>\"\n<% end %>\n	Keyword=\"<%= iif(this.flags.Managed, \"ManagedCProj\", \"Win32Proj\") %>\"\n	>\n	<Platforms>\n		<Platform\n			Name=\"Win32\"\n		/>\n	</Platforms>\n<% if _ACTION > \"vs2003\" then %>\n	<ToolFiles>\n	</ToolFiles>\n<% end %>\n	<Configurations>\n<% for cfg in premake.eachconfig(this) do %>\n		<Configuration\n			Name=\"<%= premake.esc(cfg.name) %>|Win32\"\n			OutputDirectory=\"<%= premake.esc(cfg.buildtarget.directory) %>\"\n			IntermediateDirectory=\"<%= premake.esc(cfg.objectsdir) %>\"\n			ConfigurationType=\"<%= _VS.cfgtype(cfg) %>\"\n			CharacterSet=\"<%= iif(cfg.flags.Unicode, 1, 2) %>\"\n		<% if cfg.flags.Managed then %>\n			ManagedExtensions=\"true\"\n		<% end %>\n			>\n<% for _,block in ipairs(_VS[_ACTION]) do %>\n	<% if (block == \"VCALinkTool\") then %>\n			<Tool\n				Name=\"VCALinkTool\"\n			/>\n	<% elseif (block == \"VCAppVerifierTool\") then %>\n			<Tool\n				Name=\"VCAppVerifierTool\"\n			/>\n	<% elseif (block == \"VCAuxiliaryManagedWrapperGeneratorTool\") then %>\n			<Tool\n				Name=\"VCAuxiliaryManagedWrapperGeneratorTool\"\n			/>\n	<% elseif (block == \"VCBscMakeTool\") then %>\n			<Tool\n				Name=\"VCBscMakeTool\"\n			/>\n	<% elseif (block == \"VCCLCompilerTool\") then %>\n			<Tool\n				Name=\"VCCLCompilerTool\"\n			<% if #cfg.buildoptions > 0 then %>\n				AdditionalOptions=\"<%= table.concat(premake.esc(cfg.buildoptions), \" \") %>\"\n			<% end %>\n				Optimization=\"<%= _VS.optimization(cfg) %>\"	\n			<% if cfg.flags.NoFramePointer then %>\n				OmitFramePointers=\"<%= _VS.bool(true) %>\"\n			<% end %>\n			<% if #cfg.includedirs > 0 then %>\n				AdditionalIncludeDirectories=\"<%= table.concat(premake.esc(cfg.includedirs), \";\") %>\"\n			<% end %>\n			<% if #cfg.defines > 0 then %>\n				PreprocessorDefinitions=\"<%= table.concat(premake.esc(cfg.defines), \";\") %>\"\n			<% end %>\n			<% if cfg.flags.Symbols and not cfg.flags.Managed then %>\n				MinimalRebuild=\"<%= _VS.bool(true) %>\"\n			<% end %>\n			<% if cfg.flags.NoExceptions then %>\n				ExceptionHandling=\"<%= iif(_ACTION < \"vs2005\", \"FALSE\", 0) %>\"\n			<% elseif cfg.flags.SEH and _ACTION > \"vs2003\" then %>\n				ExceptionHandling=\"2\"\n			<% end %>\n			<% if _VS.optimization(cfg) == 0 and not cfg.flags.Managed then %>\n				BasicRuntimeChecks=\"3\"\n			<% end %>\n			<% if _VS.optimization(cfg) ~= 0 then %>\n				StringPooling=\"<%= _VS.bool(true) %>\"\n			<% end %>\n				RuntimeLibrary=\"<%= _VS.runtime(cfg) %>\"\n				EnableFunctionLevelLinking=\"<%= _VS.bool(true) %>\"\n			<% if _ACTION < \"vs2005\" and not cfg.flags.NoRTTI then %>\n				RuntimeTypeInfo=\"<%= _VS.bool(true) %>\"\n			<% elseif _ACTION > \"vs2003\" and cfg.flags.NoRTTI then %>\n				RuntimeTypeInfo=\"<%= _VS.bool(false) %>\"\n			<% end %>\n			<% if cfg.flags.NativeWChar then %>\n				TreatWChar_tAsBuiltInType=\"<%= _VS.bool(true) %>\"\n			<% elseif cfg.flags.NoNativeWChar then %>\n				TreatWChar_tAsBuiltInType=\"<%= _VS.bool(false) %>\"\n			<% end %>\n			<% if not cfg.flags.NoPCH and cfg.pchheader then %>\n				UsePrecompiledHeader=\"<%= iif(_ACTION < \"vs2005\", 3, 2) %>\"\n				PrecompiledHeaderThrough=\"<%= cfg.pchheader %>\"\n			<% else %>\n				UsePrecompiledHeader=\"<%= iif(_ACTION > \"vs2003\" or cfg.flags.NoPCH, 0, 2) %>\"\n			<% end %>\n				WarningLevel=\"<%= iif(cfg.flags.ExtraWarnings, 4, 3) %>\"\n			<% if cfg.flags.FatalWarnings then %>\n				WarnAsError=\"<%= _VS.bool(true) %>\"\n			<% end %>\n			<% if _ACTION < \"vs2008\" and not cfg.flags.Managed then %>\n				Detect64BitPortabilityProblems=\"<%= _VS.bool(not cfg.flags.No64BitChecks) %>\"\n			<% end %>\n				ProgramDataBaseFileName=\"$(OutDir)\\$(ProjectName).pdb\"\n				DebugInformationFormat=\"<%= _VS.symbols(cfg) %>\"\n			/>\n	<% elseif (block == \"VCCustomBuildTool\") then %>\n			<Tool\n				Name=\"VCCustomBuildTool\"/>\n	<% elseif (block == \"VCFxCopTool\") then %>\n			<Tool\n				Name=\"VCFxCopTool\"\n			/>\n	<% elseif (block == \"VCLinkerTool\") then %>\n			<Tool\n		<% if cfg.kind ~= \"StaticLib\" then %>\n				Name=\"VCLinkerTool\"\n			<% if cfg.flags.NoImportLib then %>\n				IgnoreImportLibrary=\"<%= _VS.bool(true) %>\"\n			<% end %>\n			<% if #cfg.linkoptions > 0 then %>\n				AdditionalOptions=\"<%= table.concat(premake.esc(cfg.linkoptions), \" \") %>\"\n			<% end %>\n			<% if #cfg.links > 0 then %>\n				AdditionalDependencies=\"<%= table.concat(premake.getlinks(cfg, \"all\", \"fullpath\"), \" \") %>\"\n			<% end %>\n				OutputFile=\"$(OutDir)\\<%= cfg.buildtarget.name %>\"\n				LinkIncremental=\"<%= iif(_VS.optimization(cfg) == 0, 2, 1) %>\"\n				AdditionalLibraryDirectories=\"<%= table.concat(premake.esc(path.translate(cfg.libdirs)) , \";\") %>\"\n			<% local deffile = premake.findfile(cfg, \".def\"); if deffile then %>\n				ModuleDefinitionFile=\"<%= deffile %>\"\n			<% end %>\n			<% if cfg.flags.NoManifest then %>\n				GenerateManifest=\"<%= _VS.bool(false) %>\"\n			<% end %>\n				GenerateDebugInformation=\"<%= _VS.bool(_VS.symbols(cfg) ~= 0) %>\"\n			<% if _VS.symbols(cfg) ~= 0 then %>\n				ProgramDatabaseFile=\"$(OutDir)\\$(ProjectName).pdb\"\n			<% end %>\n				SubSystem=\"<%= iif(cfg.kind == \"ConsoleApp\", 1, 2) %>\"\n			<% if _VS.optimization(cfg) ~= 0 then %>\n				OptimizeReferences=\"2\"\n				EnableCOMDATFolding=\"2\"\n			<% end %>\n			<% if (cfg.kind == \"ConsoleApp\" or cfg.kind == \"WindowedApp\") and not cfg.flags.WinMain then %>\n				EntryPointSymbol=\"mainCRTStartup\"\n			<% end %>\n			<% if cfg.kind == \"SharedLib\" then %>\n				<% local implibname = path.translate(premake.gettarget(cfg, \"link\", \"windows\").fullpath, \"\\\\\") %>\n				ImportLibrary=\"<%= iif(cfg.flags.NoImportLib, cfg.objectsdir..\"\\\\\"..path.getname(implibname), implibname) %>\"\n			<% end %>\n				TargetMachine=\"1\"\n		<% else %>\n				Name=\"VCLibrarianTool\"\n				OutputFile=\"$(OutDir)\\<%= cfg.buildtarget.name %>\"\n		<% end %>\n			/>\n	<% elseif (block == \"VCManagedResourceCompilerTool\") then %>\n			<Tool\n				Name=\"VCManagedResourceCompilerTool\"\n			/>\n	<% elseif (block == \"VCManagedWrapperGeneratorTool\") then %>\n			<Tool\n				Name=\"VCManagedWrapperGeneratorTool\"\n			/>\n	<% elseif (block == \"VCManifestTool\") then %>\n			<Tool\n				Name=\"VCManifestTool\"\n			/>\n	<% elseif (block == \"VCMIDLTool\") then %>\n			<Tool\n				Name=\"VCMIDLTool\"\n			/>\n	<% elseif (block == \"VCPreBuildEventTool\") then %>\n			<Tool\n				Name=\"VCPreBuildEventTool\"\n				<% if #cfg.prebuildcommands > 0 then %>\n				CommandLine=\"<%= premake.esc(table.implode(cfg.prebuildcommands, \"\", \"\", \"\\r\\n\")) %>\"\n				<% end %>\n			/>\n	<% elseif (block == \"VCPreLinkEventTool\") then %>\n			<Tool\n				Name=\"VCPreLinkEventTool\"\n				<% if #cfg.prelinkcommands > 0 then %>\n				CommandLine=\"<%= premake.esc(table.implode(cfg.prelinkcommands, \"\", \"\", \"\\r\\n\")) %>\"\n				<% end %>\n			/>\n	<% elseif (block == \"VCPostBuildEventTool\") then %>\n			<Tool\n				Name=\"VCPostBuildEventTool\"\n				<% if #cfg.postbuildcommands > 0 then %>\n				CommandLine=\"<%= premake.esc(table.implode(cfg.postbuildcommands, \"\", \"\", \"\\r\\n\")) %>\"\n				<% end %>\n			/>\n	<% elseif (block == \"VCResourceCompilerTool\") then %>\n			<Tool\n				Name=\"VCResourceCompilerTool\"\n			<% if #cfg.resoptions > 0 then %>\n				AdditionalOptions=\"<%= table.concat(premake.esc(cfg.resoptions), \" \") %>\"\n			<% end %>\n			<% if #cfg.defines > 0 or #cfg.resdefines > 0 then %>\n				PreprocessorDefinitions=\"<%= table.concat(premake.esc(table.join(cfg.defines, cfg.resdefines)), \";\") %>\"\n			<% end %>\n			<% if #cfg.includedirs > 0 or #cfg.resincludedirs > 0 then %>\n				AdditionalIncludeDirectories=\"<%= table.concat(premake.esc(table.join(cfg.includedirs, cfg.resincludedirs)), \";\") %>\"\n			<% end %>\n			/>\n	<% elseif (block == \"VCWebDeploymentTool\") then %>\n			<Tool\n				Name=\"VCWebDeploymentTool\"\n			/>\n	<% elseif (block == \"VCWebServiceProxyGeneratorTool\") then %>\n			<Tool\n				Name=\"VCWebServiceProxyGeneratorTool\"\n			/>\n	<% elseif (block == \"VCXDCMakeTool\") then %>\n			<Tool\n				Name=\"VCXDCMakeTool\"\n			/>\n	<% elseif (block == \"VCXMLDataGeneratorTool\") then %>\n			<Tool\n				Name=\"VCXMLDataGeneratorTool\"\n			/>\n	<% end %>\n<% end %>\n		</Configuration>\n	<% end %>\n	</Configurations>\n	<References>\n	</References>\n	<Files>\n		<% premake.walksources(this, this.files, _VS.files) %>\n	</Files>\n	<Globals>\n	</Globals>\n</VisualStudioProject>\n]])",
	"--\n\n\n\nlocal function cleantemplatefiles(this, templates)\nif (templates) then\nfor _,tmpl in ipairs(templates) do\nlocal fname = premake.getoutputname(this, tmpl[1])\nos.remove(fname)\nend\nend\nend\n\n\n\nnewaction {\ntrigger     = \"clean\",\ndescription = \"Remove all binaries and generated files\",\ntargetstyle = \"windows\",\n\nexecute = function()\nlocal solutions = { }\nlocal projects = { }\nlocal targets = { }\n\nlocal cwd = os.getcwd()\nlocal function rebase(parent, dir)\nreturn path.rebase(dir, parent.location, cwd)\nend\n\n-- Walk the tree. Build a list of object names to pass to the cleaners,\n-- and delete any toolset agnostic files along the way.\nfor _,sln in ipairs(_SOLUTIONS) do\ntable.insert(solutions, path.join(sln.location, sln.name))\n\nfor prj in premake.eachproject(sln) do\ntable.insert(projects, path.join(prj.location, prj.name))\n\nif (prj.objectsdir) then\nos.rmdir(rebase(prj, prj.objectsdir))\nend\n\nfor cfg in premake.eachconfig(prj) do\ntable.insert(targets, path.join(rebase(cfg, cfg.buildtarget.directory), cfg.buildtarget.basename))\n\n-- remove all possible permutations of the target binary\nos.remove(rebase(cfg, premake.gettarget(cfg, \"build\", \"windows\").fullpath))\nos.remove(rebase(cfg, premake.gettarget(cfg, \"build\", \"linux\", \"linux\").fullpath))\nos.remove(rebase(cfg, premake.gettarget(cfg, \"build\", \"linux\", \"macosx\").fullpath))\nif (cfg.kind == \"WindowedApp\") then\nos.rmdir(rebase(cfg, premake.gettarget(cfg, \"build\", \"linux\", \"linux\").fullpath .. \".app\"))\nend\n\n-- if there is an import library, remove that too\nos.remove(rebase(cfg, premake.gettarget(cfg, \"link\", \"windows\").fullpath))\nos.remove(rebase(cfg, premake.gettarget(cfg, \"link\", \"linux\").fullpath))\n\nos.rmdir(rebase(cfg, cfg.objectsdir))\nend\nend\nend\n\n-- Walk the tree again. Delete templated and toolset-specific files\nfor _,action in pairs(premake.actions) do\nfor _,sln in ipairs(_SOLUTIONS) do\ncleantemplatefiles(sln, action.solutiontemplates)\nfor prj in premake.eachproject(sln) do\ncleantemplatefiles(prj, action.projecttemplates)\nend\nend\n\nif (type(action.onclean) == \"function\") then\naction.onclean(solutions, projects, targets)\nend\nend\nend,\n}\n",
	"--\n\n\nnewaction {\ntrigger         = \"codeblocks\",\nshortname       = \"Code::Blocks\",\ndescription     = \"Code::Blocks Studio\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\" },\n\nvalid_tools     = {\ncc   = { \"gcc\", \"ow\" },\n},\n\nsolutiontemplates = {\n{ \".workspace\",  _TEMPLATES.codeblocks_workspace },\n},\n\nprojecttemplates = {\n{ \".cbp\", _TEMPLATES.codeblocks_cbp },\n},\n\nonclean = function(solutions, projects, targets)\nfor _,name in ipairs(projects) do\nos.remove(name .. \".depend\")\nos.remove(name .. \".layout\")\nend\nend\n}\n",
	"--\n\n_CODELITE = { }\n\n\n\nfunction _CODELITE.kind(value)\nif (value == \"ConsoleApp\" or value == \"WindowedApp\") then\nreturn \"Executable\"\nelseif (value == \"StaticLib\") then\nreturn \"Static Library\"\nelseif (value == \"SharedLib\") then\nreturn \"Dynamic Library\"\nend\nend\n\n\n\n\nfunction _CODELITE.files(prj, fname, state, nestlevel)\nlocal indent = string.rep(\"  \", nestlevel + 1)\n\nif (state == \"GroupStart\") then\nio.write(indent .. '<VirtualDirectory Name=\"' .. path.getname(fname) .. '\">\\n')\nelseif (state == \"GroupEnd\") then\nio.write(indent .. '</VirtualDirectory>\\n')\nelse\nio.write(indent .. '<File Name=\"' .. fname .. '\"/>\\n')\nend\nend\n\n\n\nnewaction {\ntrigger         = \"codelite\",\nshortname       = \"CodeLite\",\ndescription     = \"CodeLite (experimental)\",\ntargetstyle     = \"linux\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\" },\n\nvalid_tools     = {\ncc   = { \"gcc\" },\n},\n\nsolutiontemplates = {\n{ \".workspace\",  _TEMPLATES.codelite_workspace },\n},\n\nprojecttemplates = {\n{ \".project\",  _TEMPLATES.codelite_project },\n},\n\nonclean = function(solutions, projects, targets)\nfor _,name in ipairs(solutions) do\nos.remove(name .. \"_wsp.mk\")\nos.remove(name .. \".tags\")\nend\nfor _,name in ipairs(projects) do\nos.remove(name .. \".mk\")\nos.remove(name .. \".list\")\nos.remove(name .. \".out\")\nend\nend\n}\n",
	"--\n\n_MAKE = { }\n\n\n\nfunction _MAKE.esc(value)\nif (type(value) == \"table\") then\nlocal result = { }\nfor _,v in ipairs(value) do\ntable.insert(result, _MAKE.esc(v))\nend\nreturn result\nelse\nlocal result\nresult = value:gsub(\" \", \"\\\\ \")\nresult = result:gsub(\"\\\\\", \"\\\\\\\\\")\nreturn result\nend\nend\n\n\n\n\nfunction _MAKE.getmakefilename(this, searchprjs)\n-- how many projects/solutions use this location?\nlocal count = 0\nfor _,sln in ipairs(_SOLUTIONS) do\nif (sln.location == this.location) then count = count + 1 end\nif (searchprjs) then\nfor _,prj in ipairs(sln.projects) do\nif (prj.location == this.location) then count = count + 1 end\nend\nend\nend\n\nif (count == 1) then\nreturn \"Makefile\"\nelse\nreturn this.name .. \".make\"\nend\nend\n\n\n\nfunction _MAKE.getnames(tbl)\nlocal result = table.extract(tbl, \"name\")\nfor k,v in pairs(result) do\nresult[k] = _MAKE.esc(v)\nend\nreturn result\nend\n\n\n\nnewaction {\ntrigger         = \"gmake\",\nshortname       = \"GNU Make\",\ndescription     = \"GNU makefiles for POSIX, MinGW, and Cygwin\",\ntargetstyle     = \"linux\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nvalid_tools     = {\ncc     = { \"gcc\" },\ndotnet = { \"mono\", \"ms\", \"pnet\" },\n},\n\nsolutiontemplates = {\n{\nfunction(this) return _MAKE.getmakefilename(this, false) end,  \n_TEMPLATES.make_solution \n},\n},\n\nprojecttemplates = {\n{ \nfunction(this) return _MAKE.getmakefilename(this, true) end,   \n_TEMPLATES.make_cpp,\nfunction(this) return this.language == \"C\" or this.language == \"C++\" end\n},\n{\nfunction(this) return _MAKE.getmakefilename(this, true) end,\n_TEMPLATES.make_csharp,\nfunction(this) return this.language == \"C#\" end\n},\n},\n}\n",
	"--\n\n_VS = { }\n\n\n\n_VS.vs2002 = {\n\"VCCLCompilerTool\",\n\"VCCustomBuildTool\",\n\"VCLinkerTool\",\n\"VCMIDLTool\",\n\"VCPostBuildEventTool\",\n\"VCPreBuildEventTool\",\n\"VCPreLinkEventTool\",\n\"VCResourceCompilerTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCWebDeploymentTool\"\n}\n\n_VS.vs2003 = {\n\"VCCLCompilerTool\",\n\"VCCustomBuildTool\",\n\"VCLinkerTool\",\n\"VCMIDLTool\",\n\"VCPostBuildEventTool\",\n\"VCPreBuildEventTool\",\n\"VCPreLinkEventTool\",\n\"VCResourceCompilerTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebDeploymentTool\",\n\"VCManagedWrapperGeneratorTool\",\n\"VCAuxiliaryManagedWrapperGeneratorTool\"\n}\n\n_VS.vs2005 = {\n\"VCPreBuildEventTool\",\n\"VCCustomBuildTool\",\n\"VCXMLDataGeneratorTool\",\n\"VCWebServiceProxyGeneratorTool\",\n\"VCMIDLTool\",\n\"VCCLCompilerTool\",\n\"VCManagedResourceCompilerTool\",\n\"VCResourceCompilerTool\",\n\"VCPreLinkEventTool\",\n\"VCLinkerTool\",\n\"VCALinkTool\",\n\"VCManifestTool\",\n\"VCXDCMakeTool\",\n\"VCBscMakeTool\",\n\"VCFxCopTool\",\n\"VCAppVerifierTool\",\n\"VCWebDeploymentTool\",\n\"VCPostBuildEventTool\"\n}\n\n_VS.vs2008 = _VS.vs2005\n\n\n\nfunction _VS.onclean(solutions, projects, targets)\nfor _,name in ipairs(solutions) do\nos.remove(name .. \".suo\")\nos.remove(name .. \".ncb\")\nend\n\nfor _,name in ipairs(projects) do\nos.remove(name .. \".csproj.user\")\nos.remove(name .. \".csproj.webinfo\")\n\nlocal files = os.matchfiles(name .. \".vcproj.*.user\", name .. \".csproj.*.user\")\nfor _, fname in ipairs(files) do\nos.remove(fname)\nend\nend\n\nfor _,name in ipairs(targets) do\nos.remove(name .. \".pdb\")\nos.remove(name .. \".idb\")\nos.remove(name .. \".ilk\")\nos.remove(name .. \".vshost.exe\")\nos.remove(name .. \".exe.manifest\")\nend\nend\n\n\n\nfunction _VS.arch(prj)\nif (prj.language == \"C#\") then\nif (_ACTION < \"vs2005\") then\nreturn \".NET\"\nelse\nreturn \"Any CPU\"\nend\nelse\nreturn \"Win32\"\nend\nend\n\n\n\n\nfunction _VS.bool(value)\nif (_ACTION < \"vs2005\") then\nreturn iif(value, \"TRUE\", \"FALSE\")\nelse\nreturn iif(value, \"true\", \"false\")\nend\nend\n\n\n\n\nfunction _VS.cfgtype(cfg)\nif (cfg.kind == \"SharedLib\") then\nreturn 2\nelseif (cfg.kind == \"StaticLib\") then\nreturn 4\nelse\nreturn 1\nend\nend\n\n\n\n\nlocal function output(indent, value)\nio.write(indent .. value .. \"\\r\\n\")\nend\n\nlocal function attrib(indent, name, value)\nio.write(indent .. \"\\t\" .. name .. '=\"' .. value .. '\"\\r\\n')\nend\n\nfunction _VS.files(prj, fname, state, nestlevel)\nlocal indent = string.rep(\"\\t\", nestlevel + 2)\n\nif (state == \"GroupStart\") then\noutput(indent, \"<Filter\")\nattrib(indent, \"Name\", path.getname(fname))\nattrib(indent, \"Filter\", \"\")\noutput(indent, \"\\t>\")\n\nelseif (state == \"GroupEnd\") then\noutput(indent, \"</Filter>\")\n\nelse\noutput(indent, \"<File\")\nattrib(indent, \"RelativePath\", path.translate(fname, \"\\\\\"))\noutput(indent, \"\\t>\")\nif (not prj.flags.NoPCH and prj.pchsource == fname) then\nfor _, cfgname in ipairs(prj.configurations) do\noutput(indent, \"\\t<FileConfiguration\")\nattrib(indent, \"\\tName\", cfgname .. \"|Win32\")\noutput(indent, \"\\t\\t>\")\noutput(indent, \"\\t\\t<Tool\")\nattrib(indent, \"\\t\\tName\", \"VCCLCompilerTool\")\nattrib(indent, \"\\t\\tUsePrecompiledHeader\", \"1\")\noutput(indent, \"\\t\\t/>\")\noutput(indent, \"\\t</FileConfiguration>\")\nend\nend\noutput(indent, \"</File>\")\nend\nend\n\n\n\n\nfunction _VS.optimization(cfg)\nlocal result = 0\nfor _, value in ipairs(cfg.flags) do\nif (value == \"Optimize\") then\nresult = 3\nelseif (value == \"OptimizeSize\") then\nresult = 1\nelseif (value == \"OptimizeSpeed\") then\nresult = 2\nend\nend\nreturn result\nend\n\n\n\n\nfunction _VS.projectfile(prj)\nlocal extension\nif (prj.language == \"C#\") then\nextension = \".csproj\"\nelse\nextension = \".vcproj\"\nend\n\nlocal fname = path.join(prj.location, prj.name)\nreturn fname..extension\nend\n\n\n\n\nfunction _VS.runtime(cfg)\nlocal debugbuild = (_VS.optimization(cfg) == 0)\nif (cfg.flags.StaticRuntime) then\nreturn iif(debugbuild, 1, 0)\nelse\nreturn iif(debugbuild, 3, 2)\nend\nend\n\n\n\n\nfunction _VS.symbols(cfg)\nif (not cfg.flags.Symbols) then\nreturn 0\nelse\n-- Edit-and-continue does't work if optimizing or managed C++\nif (cfg.flags.NoEditAndContinue or _VS.optimization(cfg) ~= 0 or cfg.flags.Managed) then\nreturn 3\nelse\nreturn 4\nend\nend\nend\n\n\n\n\nfunction _VS.tool(prj)\nif (prj.language == \"C#\") then\nreturn \"FAE04EC0-301F-11D3-BF4B-00C04F79EFBC\"\nelse\nreturn \"8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942\"\nend\nend\n\n\n\n\n\nnewaction {\ntrigger         = \"vs2002\",\nshortname       = \"Visual Studio 2002\",\ndescription     = \"Microsoft Visual Studio 2002\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",  _TEMPLATES.vs2002_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\", _TEMPLATES.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\", _TEMPLATES.vs2002_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", _TEMPLATES.vs2002_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n\nnewaction {\ntrigger         = \"vs2003\",\nshortname       = \"Visual Studio 2003\",\ndescription     = \"Microsoft Visual Studio 2003\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",  _TEMPLATES.vs2003_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\", _TEMPLATES.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\", _TEMPLATES.vs2002_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", _TEMPLATES.vs2002_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n\nnewaction {\ntrigger         = \"vs2005\",\nshortname       = \"Visual Studio 2005\",\ndescription     = \"Microsoft Visual Studio 2005 (SharpDevelop, MonoDevelop)\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",  _TEMPLATES.vs2005_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\",   _TEMPLATES.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\",   _TEMPLATES.vs2005_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", _TEMPLATES.vs2005_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n\nnewaction {\ntrigger         = \"vs2008\",\nshortname       = \"Visual Studio 2008\",\ndescription     = \"Microsoft Visual Studio 2008\",\ntargetstyle     = \"windows\",\n\nvalid_kinds     = { \"ConsoleApp\", \"WindowedApp\", \"StaticLib\", \"SharedLib\" },\n\nvalid_languages = { \"C\", \"C++\", \"C#\" },\n\nsolutiontemplates = {\n{ \".sln\",  _TEMPLATES.vs2005_solution },\n},\n\nprojecttemplates = {\n{ \".vcproj\", _TEMPLATES.vs200x_vcproj, function(this) return this.language ~= \"C#\" end },\n{ \".csproj\", _TEMPLATES.vs2005_csproj, function(this) return this.language == \"C#\" end },\n{ \".csproj.user\", _TEMPLATES.vs2005_csproj_user, function(this) return this.language == \"C#\" end },\n},\n\nonclean = _VS.onclean,\n}\n",
	0
};
