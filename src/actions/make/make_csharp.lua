--
-- make_csharp.lua
-- Generate a C# project makefile.
-- Copyright (c) 2002-2009 Jason Perkins and the Premake project
--

--
-- Given a .resx resource file, builds the path to corresponding .resource
-- file, matching the behavior and naming of Visual Studio.
--
		
	local function getresourcefilename(cfg, fname)
		if path.getextension(fname) == ".resx" then
		    local name = cfg.buildtarget.basename .. "."
		    local dir = path.getdirectory(fname)
		    if dir ~= "." then 
				name = name .. path.translate(dir, ".") .. "."
			end
			return "$(OBJDIR)/" .. name .. path.getbasename(fname) .. ".resources"
		else
			return fname
		end
	end


--
-- Main function
--
	
	function premake.make_csharp(prj)
		local csc = premake.csc

		-- Do some processing up front: build a list of configuration-dependent libraries.
		-- Libraries that are built to a location other than $(TARGETDIR) will need to
		-- be copied so they can be found at runtime.
		local cfglibs = { }
		local cfgpairs = { }
		local anycfg
		for cfg in premake.eachconfig(prj) do
			anycfg = cfg
			cfglibs[cfg] = premake.getlinks(cfg, "siblings", "fullpath")
			cfgpairs[cfg] = { }
			for _, fname in ipairs(cfglibs[cfg]) do
				if path.getdirectory(fname) ~= cfg.buildtarget.directory then
					cfgpairs[cfg]["$(TARGETDIR)/"..path.getname(fname)] = fname
				end
			end
		end
		
		-- sort the files into categories, based on their build action
		local sources = {}
		local embedded = { }
		local copypairs = { }
		
		for fcfg in premake.eachfile(prj) do
			local action = csc.getbuildaction(fcfg)
			if action == "Compile" then
				table.insert(sources, fcfg.name)
			elseif action == "EmbeddedResource" then			
				table.insert(embedded, fcfg.name)
			elseif action == "Content" then
				copypairs["$(TARGETDIR)/"..path.getname(fcfg.name)] = fcfg.name
			elseif path.getname(fcfg.name):lower() == "app.config" then
				copypairs["$(TARGET).config"] = fcfg.name	
			end
		end

		-- Any assemblies that are on the library search paths should be copied
		-- to $(TARGETDIR) so they can be found at runtime
		local paths = table.translate(prj.libdirs, function(v) return path.join(prj.basedir, v) end)
		paths = table.join({prj.basedir}, paths)
		for _, libname in ipairs(premake.getlinks(prj, "system", "fullpath")) do
			local libdir = os.pathsearch(libname..".dll", unpack(paths))
			if (libdir) then
				local target = "$(TARGETDIR)/"..path.getname(libname)
				local source = path.getrelative(prj.basedir, path.join(libdir, libname))..".dll"
				copypairs[target] = source
			end
		end
		
		-- end of preprocessing --


		-- set up the environment
		io.printf('# %s project makefile autogenerated by Premake', premake.actions[_ACTION].shortname)
		io.printf('')
		
		io.printf('ifndef config')
		io.printf('  config=%s', _MAKE.esc(prj.configurations[1]:lower()))
		io.printf('endif')
		io.printf('')
		
		io.printf('ifndef verbose')
		io.printf('  SILENT = @')
		io.printf('endif')
		io.printf('')
		
		io.printf('ifndef CSC')
		io.printf('  CSC=%s', csc.getcompilervar(prj))
		io.printf('endif')
		io.printf('')
		
		io.printf('ifndef RESGEN')
		io.printf('  RESGEN=resgen')
		io.printf('endif')
		io.printf('')

		-- write the configuration blocks
		for cfg in premake.eachconfig(prj) do
			io.printf('ifeq ($(config),%s)', _MAKE.esc(cfg.name:lower()))
			io.printf('  TARGETDIR  := %s', _MAKE.esc(cfg.buildtarget.directory))
			io.printf('  OBJDIR     := %s', _MAKE.esc(cfg.objectsdir))
			io.printf('  DEPENDS    := %s', table.concat(_MAKE.esc(premake.getlinks(cfg, "dependencies", "fullpath")), " "))
			io.printf('  REFERENCES := %s', table.implode(_MAKE.esc(cfglibs[cfg]), "/r:", "", " "))
			io.printf('  FLAGS      += %s %s', table.concat(csc.getflags(cfg), " "), table.implode(cfg.defines, "/d:", "", " "))
			
			io.printf('  define PREBUILDCMDS')
			if #cfg.prebuildcommands > 0 then
				io.printf('\t@echo Running pre-build commands')
				io.printf('\t%s', table.implode(cfg.prebuildcommands, "", "", "\n\t"))
			end
			io.printf('  endef')
			
			io.printf('  define PRELINKCMDS')
			if #cfg.prelinkcommands > 0 then
				io.printf('\t@echo Running pre-link commands')
				io.printf('\t%s', table.implode(cfg.prelinkcommands, "", "", "\n\t"))
			end
			io.printf('  endef')
			
			io.printf('  define POSTBUILDCMDS')
			if #cfg.postbuildcommands > 0 then
				io.printf('\t@echo Running post-build commands')
				io.printf('\t%s', table.implode(cfg.postbuildcommands, "", "", "\n\t"))
			end
			io.printf('  endef')
			
			io.printf('endif')
			io.printf('')
		end

		-- set project level values
		io.printf('# To maintain compatibility with VS.NET, these values must be set at the project level')
		io.printf('TARGET      = $(TARGETDIR)/%s', _MAKE.esc(prj.buildtarget.name))
		io.printf('FLAGS      += /t:%s %s', csc.getkind(prj):lower(), table.implode(_MAKE.esc(prj.libdirs), "/lib:", "", " "))
		io.printf('REFERENCES += %s', table.implode(_MAKE.esc(premake.getlinks(prj, "system", "basename")), "/r:", ".dll", " "))
		io.printf('')
		
		-- list source files
		io.printf('SOURCES := \\')
		for _, fname in ipairs(sources) do
			io.printf('\t%s \\', _MAKE.esc(path.translate(fname)))
		end
		io.printf('')
		
		io.printf('EMBEDFILES := \\')
		for _, fname in ipairs(embedded) do
			io.printf('\t%s \\', _MAKE.esc(getresourcefilename(prj, fname)))
		end
		io.printf('')

		io.printf('COPYFILES += \\')
		for target, source in pairs(cfgpairs[anycfg]) do
			io.printf('\t%s \\', _MAKE.esc(target))
		end
		for target, source in pairs(copypairs) do
			io.printf('\t%s \\', _MAKE.esc(target))
		end
		io.printf('')

		-- set up support commands like mkdir, rmdir, etc. based on the shell
		io.printf('SHELLTYPE := msdos')
		io.printf('ifeq (,$(ComSpec)$(COMSPEC))')
		io.printf('  SHELLTYPE := posix')
		io.printf('endif')
		io.printf('ifeq (/bin,$(findstring /bin,$(SHELL)))')
		io.printf('  SHELLTYPE := posix')
		io.printf('endif')
		io.printf('ifeq (posix,$(SHELLTYPE))')
		io.printf('   define MKDIR_RULE')
		io.printf('\t@echo Creating $@')
		io.printf('\t$(SILENT) mkdir -p $@')
		io.printf('   endef')
		io.printf('  define COPY_RULE')
		io.printf('\t@echo Copying $(notdir $@)')
		io.printf('\t$(SILENT) cp -fR $^ $@')
		io.printf('  endef')
		io.printf('else')
		io.printf('   define MKDIR_RULE')
		io.printf('\t@echo Creating $@')
		io.printf('\t$(SILENT) mkdir $(subst /,\\\\,$@)')
		io.printf('   endef')
		io.printf('  define COPY_RULE')
		io.printf('\t@echo Copying $(notdir $@)')
		io.printf('\t$(SILENT) copy /Y $(subst /,\\\\,$^) $(subst /,\\\\,$@)')
		io.printf('  endef')
		io.printf('endif')

		-- main build rule(s)
		io.printf('.PHONY: clean prebuild prelink')
		io.printf('')
		
		io.printf('all: $(TARGETDIR) $(OBJDIR) prebuild $(EMBEDFILES) $(COPYFILES) prelink $(TARGET)')
		io.printf('')
		
		io.printf('$(TARGET): $(SOURCES) $(EMBEDFILES) $(DEPENDS)')
		io.printf('\t$(SILENT) $(CSC) /nologo /out:$@ $(FLAGS) $(REFERENCES) $(SOURCES) $(patsubst %%,/resource:%%,$(EMBEDFILES))')
		io.printf('\t$(POSTBUILDCMDS)')
		io.printf('')

		-- create destination directories
		io.printf('$(TARGETDIR):')
		io.printf('\t$(MKDIR_RULE)')
		io.printf('')
		
		io.printf('$(OBJDIR):')
		io.printf('\t$(MKDIR_RULE)')
		io.printf('')

		-- clean target
		io.printf('clean:')
		io.printf('\t@echo Cleaning %s', prj.name)
		io.printf('ifeq (posix,$(SHELLTYPE))')
		io.printf('\t$(SILENT) rm -f $(TARGETDIR)/%s.* $(COPYFILES)', prj.buildtarget.basename)
		io.printf('\t$(SILENT) rm -rf $(OBJDIR)')
		io.printf('else')
		io.printf('\t$(SILENT) if exist $(subst /,\\\\,$(TARGETDIR)/%s.*) del $(subst /,\\\\,$(TARGETDIR)/%s.*)', prj.buildtarget.basename, prj.buildtarget.basename)
		for target, source in pairs(cfgpairs[anycfg]) do
			io.printf('\t$(SILENT) if exist $(subst /,\\\\,%s) del $(subst /,\\\\,%s)', target, target)
		end
		for target, source in pairs(copypairs) do
			io.printf('\t$(SILENT) if exist $(subst /,\\\\,%s) del $(subst /,\\\\,%s)', target, target)
		end
		io.printf('\t$(SILENT) if exist $(subst /,\\\\,$(OBJDIR)) rmdir /s /q $(subst /,\\\\,$(OBJDIR))')
		io.printf('endif')
		io.printf('')

		-- custom build step targets
		io.printf('prebuild:')
		io.printf('\t$(PREBUILDCMDS)')
		io.printf('')
		
		io.printf('prelink:')
		io.printf('\t$(PRELINKCMDS)')
		io.printf('')

		-- per-file rules
		io.printf('# Per-configuration copied file rules')
		for cfg in premake.eachconfig(prj) do
			io.printf('ifeq ($(config),%s)', _MAKE.esc(cfg.name:lower()))
			for target, source in pairs(cfgpairs[cfg]) do
				io.printf('%s: %s', _MAKE.esc(target), _MAKE.esc(source))
				io.printf('\t$(COPY_RULE)')
			end
			io.printf('endif')
		end
		io.printf('')
		
		io.printf('# Copied file rules')
		for target, source in pairs(copypairs) do
			io.printf('%s: %s', _MAKE.esc(target), _MAKE.esc(source))
			io.printf('\t$(COPY_RULE)')
			io.printf('')
		end

		io.printf('# Embedded file rules')
		for _, fname in ipairs(embedded) do 
			if path.getextension(fname) == ".resx" then
				io.printf('%s: %s', _MAKE.esc(getresourcefilename(prj, fname)), _MAKE.esc(fname))
				io.printf('\t$(SILENT) $(RESGEN) $^ $@')
			end
			io.printf('')
		end
		
	end
